{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Data to Science Python (d2spy)","text":"<p>D2spy is a Python package for interacting with Data to Science instances.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Sign in to your Data to Science instance</li> <li>Access your projects, flights, and data products</li> <li>Create new projects and flights</li> <li>Upload data products to flights</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>D2spy supports two installation modes:</p> <p>Core Installation (minimal dependencies): <pre><code>pip install d2spy\n</code></pre> Includes full API access for authentication, project/flight management, data uploads, and server-side analysis tools (NDVI, ExG, zonal statistics).</p> <p>Geo Installation (with geospatial dependencies): <pre><code>pip install d2spy[geo]\n</code></pre> Adds client-side geospatial processing capabilities including raster clipping, EXIF extraction, and bounding box generation. Requires <code>rasterio</code>, <code>geopandas</code>, and <code>exifread</code>.</p>"},{"location":"#learn-more","title":"Learn more","text":"<p>\ud83d\udc49 Visit the official D2S homepage to learn more.</p>"},{"location":"api_client/","title":"api_client module","text":"<p>Makes API requests to D2S API.</p> Source code in <code>d2spy/api_client.py</code> <pre><code>class APIClient:\n    \"\"\"Makes API requests to D2S API.\"\"\"\n\n    def __init__(self, base_url: str, session: Session):\n        \"\"\"Constructor for APIClient class.\n\n        Args:\n            base_url (str): Base URL for D2S instance.\n            session (Session): Session set by Auth.\n\n        Raises:\n            ValueError: Raised if access token missing from session.\n        \"\"\"\n        self.base_url = base_url\n        self.session = session\n        self._is_refreshing = False\n        self._refresh_lock = threading.Lock()\n\n        # Check if access token in session cookies (avoid ambiguous .get())\n        if not any(cookie.name == \"access_token\" for cookie in self.session.cookies):\n            raise ValueError(\"Session missing access token. Must sign in first.\")\n\n    def _refresh_access_token(self) -&gt; bool:\n        \"\"\"Refresh the access token using the refresh token.\n\n        Returns:\n            bool: True if refresh successful, False otherwise.\n        \"\"\"\n        # Ensure a refresh_token exists (avoid ambiguous .get())\n        if not any(cookie.name == \"refresh_token\" for cookie in self.session.cookies):\n            return False\n\n        url = f\"{self.base_url}/api/v1/auth/refresh-token\"\n        try:\n            response = self.session.post(url)\n            if response.status_code == 200:\n                # Normalize cookies to be scoped to the API host to avoid duplicates\n                host = urlparse(self.base_url).hostname or \"\"\n                if \"access_token\" in response.cookies:\n                    # Don't set explicit domain for localhost to\n                    # avoid port-matching issues\n                    if host == \"localhost\" or host == \"127.0.0.1\":\n                        self.session.cookies.set(\n                            \"access_token\",\n                            response.cookies[\"access_token\"],\n                            path=\"/\",\n                        )\n                    else:\n                        self.session.cookies.set(\n                            \"access_token\",\n                            response.cookies[\"access_token\"],\n                            domain=host,\n                            path=\"/\",\n                        )\n                if \"refresh_token\" in response.cookies:\n                    # Don't set explicit domain for localhost to avoid\n                    # port-matching issues\n                    if host == \"localhost\" or host == \"127.0.0.1\":\n                        self.session.cookies.set(\n                            \"refresh_token\",\n                            response.cookies[\"refresh_token\"],\n                            path=\"/\",\n                        )\n                    else:\n                        self.session.cookies.set(\n                            \"refresh_token\",\n                            response.cookies[\"refresh_token\"],\n                            domain=host,\n                            path=\"/\",\n                        )\n                return True\n            else:\n                return False\n        except Exception:\n            return False\n\n    def _make_request_with_retry(\n        self, method: str, endpoint: str, **kwargs\n    ) -&gt; Response:\n        \"\"\"Make request with automatic token refresh on 401 errors.\n\n        Args:\n            method (str): HTTP method (GET, POST, PUT, etc.)\n            endpoint (str): D2S endpoint for request.\n            **kwargs: Additional arguments for the request.\n\n        Returns:\n            Response: The response object.\n\n        Raises:\n            Exception: If token refresh fails or request fails after retry.\n        \"\"\"\n        url = self.base_url + endpoint\n\n        # Extract _retry flag and remove it from kwargs before making request\n        is_retry = kwargs.pop(\"_retry\", False)\n\n        # Make the initial request\n        response = getattr(self.session, method.lower())(url, **kwargs)\n\n        # If we get a 401 and it's not the refresh endpoint, try to refresh\n        if (\n            response.status_code == 401\n            and endpoint != \"/api/v1/auth/refresh-token\"\n            and not is_retry\n        ):\n\n            with self._refresh_lock:\n                if not self._is_refreshing:\n                    self._is_refreshing = True\n                    try:\n                        # Attempt to refresh the token\n                        if self._refresh_access_token():\n                            # Retry the original request\n                            kwargs[\"_retry\"] = True\n                            response = self._make_request_with_retry(\n                                method, endpoint, **kwargs\n                            )\n                        else:\n                            # Refresh failed, clear session\n                            self.session.cookies.clear()\n                            raise ValueError(\n                                \"Session expired and refresh failed. \"\n                                \"Please login again.\"\n                            )\n                    finally:\n                        self._is_refreshing = False\n                else:\n                    # Another thread is already refreshing, wait and retry once\n                    import time\n\n                    time.sleep(0.1)\n                    kwargs[\"_retry\"] = True\n                    response = self._make_request_with_retry(method, endpoint, **kwargs)\n\n        return response\n\n    def make_get_request(\n        self, endpoint: str, **kwargs\n    ) -&gt; Union[Dict[Any, Any], List[Dict[Any, Any]]]:\n        \"\"\"Makes GET request to D2S API.\n\n        Args:\n            endpoint (str): D2S endpoint for request.\n\n        Returns:\n            Union[Dict, List]: JSON response from request.\n        \"\"\"\n        response = self._make_request_with_retry(\"GET\", endpoint, **kwargs)\n\n        if response.status_code != 200:\n            pretty_print_response(response)\n            response.raise_for_status()\n\n        return response.json()\n\n    def make_post_request(self, endpoint: str, **kwargs) -&gt; Dict[Any, Any]:\n        \"\"\"Make POST request to D2S API.\n\n        Args:\n            endpoint (str): D2S endpoint for request.\n\n        Returns:\n            Dict: JSON response from request.\n        \"\"\"\n        response = self._make_request_with_retry(\"POST\", endpoint, **kwargs)\n\n        if (\n            response.status_code != 200\n            and response.status_code != 201\n            and response.status_code != 202\n        ):\n            pretty_print_response(response)\n            response.raise_for_status()\n\n        if response.status_code == 202:\n            return {\"status\": \"accepted\"}\n\n        return response.json()\n\n    def make_put_request(self, endpoint: str, **kwargs) -&gt; Dict[Any, Any]:\n        \"\"\"Make PUT request to D2S API.\n\n        Args:\n            endpoint (str): D2S endpoint for request.\n\n        Returns:\n            Dict: JSON response from request.\n        \"\"\"\n        response = self._make_request_with_retry(\"PUT\", endpoint, **kwargs)\n\n        if response.status_code != 200:\n            pretty_print_response(response)\n            response.raise_for_status()\n\n        return response.json()\n</code></pre>"},{"location":"api_client/#d2spy.api_client.APIClient.__init__","title":"<code>__init__(base_url, session)</code>","text":"<p>Constructor for APIClient class.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for D2S instance.</p> required <code>session</code> <code>Session</code> <p>Session set by Auth.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if access token missing from session.</p> Source code in <code>d2spy/api_client.py</code> <pre><code>def __init__(self, base_url: str, session: Session):\n    \"\"\"Constructor for APIClient class.\n\n    Args:\n        base_url (str): Base URL for D2S instance.\n        session (Session): Session set by Auth.\n\n    Raises:\n        ValueError: Raised if access token missing from session.\n    \"\"\"\n    self.base_url = base_url\n    self.session = session\n    self._is_refreshing = False\n    self._refresh_lock = threading.Lock()\n\n    # Check if access token in session cookies (avoid ambiguous .get())\n    if not any(cookie.name == \"access_token\" for cookie in self.session.cookies):\n        raise ValueError(\"Session missing access token. Must sign in first.\")\n</code></pre>"},{"location":"api_client/#d2spy.api_client.APIClient.make_get_request","title":"<code>make_get_request(endpoint, **kwargs)</code>","text":"<p>Makes GET request to D2S API.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>D2S endpoint for request.</p> required <p>Returns:</p> Type Description <code>Union[Dict[Any, Any], List[Dict[Any, Any]]]</code> <p>Union[Dict, List]: JSON response from request.</p> Source code in <code>d2spy/api_client.py</code> <pre><code>def make_get_request(\n    self, endpoint: str, **kwargs\n) -&gt; Union[Dict[Any, Any], List[Dict[Any, Any]]]:\n    \"\"\"Makes GET request to D2S API.\n\n    Args:\n        endpoint (str): D2S endpoint for request.\n\n    Returns:\n        Union[Dict, List]: JSON response from request.\n    \"\"\"\n    response = self._make_request_with_retry(\"GET\", endpoint, **kwargs)\n\n    if response.status_code != 200:\n        pretty_print_response(response)\n        response.raise_for_status()\n\n    return response.json()\n</code></pre>"},{"location":"api_client/#d2spy.api_client.APIClient.make_post_request","title":"<code>make_post_request(endpoint, **kwargs)</code>","text":"<p>Make POST request to D2S API.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>D2S endpoint for request.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict[Any, Any]</code> <p>JSON response from request.</p> Source code in <code>d2spy/api_client.py</code> <pre><code>def make_post_request(self, endpoint: str, **kwargs) -&gt; Dict[Any, Any]:\n    \"\"\"Make POST request to D2S API.\n\n    Args:\n        endpoint (str): D2S endpoint for request.\n\n    Returns:\n        Dict: JSON response from request.\n    \"\"\"\n    response = self._make_request_with_retry(\"POST\", endpoint, **kwargs)\n\n    if (\n        response.status_code != 200\n        and response.status_code != 201\n        and response.status_code != 202\n    ):\n        pretty_print_response(response)\n        response.raise_for_status()\n\n    if response.status_code == 202:\n        return {\"status\": \"accepted\"}\n\n    return response.json()\n</code></pre>"},{"location":"api_client/#d2spy.api_client.APIClient.make_put_request","title":"<code>make_put_request(endpoint, **kwargs)</code>","text":"<p>Make PUT request to D2S API.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>D2S endpoint for request.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict[Any, Any]</code> <p>JSON response from request.</p> Source code in <code>d2spy/api_client.py</code> <pre><code>def make_put_request(self, endpoint: str, **kwargs) -&gt; Dict[Any, Any]:\n    \"\"\"Make PUT request to D2S API.\n\n    Args:\n        endpoint (str): D2S endpoint for request.\n\n    Returns:\n        Dict: JSON response from request.\n    \"\"\"\n    response = self._make_request_with_retry(\"PUT\", endpoint, **kwargs)\n\n    if response.status_code != 200:\n        pretty_print_response(response)\n        response.raise_for_status()\n\n    return response.json()\n</code></pre>"},{"location":"api_reference/","title":"API Reference","text":"<p>Listed below are the modules available through the d2spy. Most users will only interact with <code>auth</code> and <code>workspace</code>.</p>"},{"location":"api_reference/#modules","title":"Modules","text":"<ul> <li>api_client module</li> <li>auth module</li> <li>data_product_collection module</li> <li>flight module</li> <li>flight_collection module</li> <li>project module</li> <li>project_collection module</li> <li>workspace module</li> </ul>"},{"location":"auth/","title":"auth module","text":"<p>Authenticates with D2S.</p> Source code in <code>d2spy/auth.py</code> <pre><code>class Auth:\n    \"\"\"Authenticates with D2S.\"\"\"\n\n    def __init__(self, base_url: str) -&gt; None:\n        \"\"\"Constructor for Auth class.\n\n        Args:\n            base_url (str): Base URL for D2S instance.\n\n        Raises:\n            ValueError: Raised if unable to communicate with host.\n        \"\"\"\n        self.base_url: str = base_url\n\n        if is_valid_base_url(self.base_url) is False:\n            raise ValueError(\"unable to connect to provided host\")\n\n        self.session: D2SpySession = D2SpySession()\n\n    def login(\n        self,\n        email: Optional[str] = None,\n        password: Optional[str] = None,\n        skip_env: bool = False,\n    ) -&gt; Optional[D2SpySession]:\n        \"\"\"Login to D2S platform with email and password. Alternatively, use\n        environment variables `D2S_EMAIL` and `D2S_PASSWORD` to set email and password.\n        If the password is not passed as an argument and `D2S_PASSWORD` is not set,\n        `getpass` will be used to prompt user for password.\n\n        Args:\n            email Optional[str]: Email address used to sign in to D2S.\n            password Optional[str]: Password used to sign in to D2S.\n            skip_env bool: Skip checking environment variables for password.\n\n        Returns:\n            Optional[D2SpySession]: Session with user access cookie.\n        \"\"\"\n        # Check for email environment variable if not provided as argument\n        if not email:\n            email = os.environ.get(\"D2S_EMAIL\")\n            if not email:\n                raise ValueError(\n                    \"Must provide 'email' to login method as argument or set email \"\n                    \"as environment variable 'D2S_EMAIL'\"\n                )\n        # Check for password environment variable if not provided as argument\n        if not password:\n            password = os.environ.get(\"D2S_PASSWORD\")\n            # Request password from user if not set as environment variable\n            if not password or (password and skip_env):\n                password = getpass.getpass(prompt=\"Enter your D2S password:\")\n        # Credentials that will be sent to D2S auth API\n        credentials = {\"username\": email, \"password\": password}\n        # URL for D2S access-token endpoint\n        url = f\"{self.base_url}/api/v1/auth/access-token\"\n        # Post credentials to access-token endpoint\n        response = requests.post(url, data=credentials)\n        # JWT access token returned for successful request\n        if response.status_code == 200 and \"access_token\" in response.cookies:\n            # Normalize cookies to be scoped to the API host to avoid duplicates\n            host = urlparse(self.base_url).hostname or \"\"\n            token_value = response.cookies[\"access_token\"]\n            # Don't set explicit domain for localhost to avoid port-matching issues\n            if host == \"localhost\" or host == \"127.0.0.1\":\n                self.session.cookies.set(\n                    \"access_token\",\n                    token_value,\n                    path=\"/\",\n                )\n            else:\n                self.session.cookies.set(\n                    \"access_token\",\n                    token_value,\n                    domain=host,\n                    path=\"/\",\n                )\n            if \"refresh_token\" in response.cookies:\n                refresh_value = response.cookies[\"refresh_token\"]\n                # Don't set explicit domain for localhost to avoid port-matching issues\n                if host == \"localhost\" or host == \"127.0.0.1\":\n                    self.session.cookies.set(\n                        \"refresh_token\",\n                        refresh_value,\n                        path=\"/\",\n                    )\n                else:\n                    self.session.cookies.set(\n                        \"refresh_token\",\n                        refresh_value,\n                        domain=host,\n                        path=\"/\",\n                    )\n            # Fetch user object associated with access token\n            user = self.get_current_user()\n            # Return dictionary of user attributes and values\n            if user:\n                # Check if user has api key and set it to session header if so\n                if hasattr(user, \"api_access_token\") and user.api_access_token:\n                    self.session.d2s_data = {\"API_KEY\": user.api_access_token}\n                return self.session\n            else:\n                return None\n        elif response.status_code == 401:\n            self.login(email, password=None, skip_env=True)\n            return None\n        else:\n            # Print response if request fails\n            pretty_print_response(response)\n            return None\n\n    def logout(self) -&gt; None:\n        \"\"\"Logout of D2S platform.\"\"\"\n        # Delete access-token and refresh-token cookies from session and end session\n        # Clear all cookies to avoid domain-matching issues\n        # (cookies may be stored with different domains depending on host type)\n        for cookie in list(self.session.cookies):\n            if cookie.name in [\"access_token\", \"refresh_token\"]:\n                self.session.cookies.clear(cookie.domain, cookie.path, cookie.name)\n        self.session.close()\n        print(\"session ended\")\n\n    def get_current_user(self) -&gt; Optional[User]:\n        \"\"\"Get user object for logged in user.\n\n        Returns:\n            Optional[User]: User object or None.\n        \"\"\"\n        # D2S endpoint for fetching user object for signed in user\n        url = f\"{self.base_url}/api/v1/users/current\"\n        # Request user object from D2S instance\n        response = self.session.get(url)\n        # Return user object if request successful\n        if response.status_code == 200:\n            return User.from_dict(response.json())\n        else:\n            # Print response if request fails\n            pretty_print_response(response)\n            return None\n</code></pre>"},{"location":"auth/#d2spy.auth.Auth.__init__","title":"<code>__init__(base_url)</code>","text":"<p>Constructor for Auth class.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for D2S instance.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if unable to communicate with host.</p> Source code in <code>d2spy/auth.py</code> <pre><code>def __init__(self, base_url: str) -&gt; None:\n    \"\"\"Constructor for Auth class.\n\n    Args:\n        base_url (str): Base URL for D2S instance.\n\n    Raises:\n        ValueError: Raised if unable to communicate with host.\n    \"\"\"\n    self.base_url: str = base_url\n\n    if is_valid_base_url(self.base_url) is False:\n        raise ValueError(\"unable to connect to provided host\")\n\n    self.session: D2SpySession = D2SpySession()\n</code></pre>"},{"location":"auth/#d2spy.auth.Auth.get_current_user","title":"<code>get_current_user()</code>","text":"<p>Get user object for logged in user.</p> <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: User object or None.</p> Source code in <code>d2spy/auth.py</code> <pre><code>def get_current_user(self) -&gt; Optional[User]:\n    \"\"\"Get user object for logged in user.\n\n    Returns:\n        Optional[User]: User object or None.\n    \"\"\"\n    # D2S endpoint for fetching user object for signed in user\n    url = f\"{self.base_url}/api/v1/users/current\"\n    # Request user object from D2S instance\n    response = self.session.get(url)\n    # Return user object if request successful\n    if response.status_code == 200:\n        return User.from_dict(response.json())\n    else:\n        # Print response if request fails\n        pretty_print_response(response)\n        return None\n</code></pre>"},{"location":"auth/#d2spy.auth.Auth.login","title":"<code>login(email=None, password=None, skip_env=False)</code>","text":"<p>Login to D2S platform with email and password. Alternatively, use environment variables <code>D2S_EMAIL</code> and <code>D2S_PASSWORD</code> to set email and password. If the password is not passed as an argument and <code>D2S_PASSWORD</code> is not set, <code>getpass</code> will be used to prompt user for password.</p> <p>Parameters:</p> Name Type Description Default <code>email Optional[str]</code> <p>Email address used to sign in to D2S.</p> required <code>password Optional[str]</code> <p>Password used to sign in to D2S.</p> required <code>skip_env bool</code> <p>Skip checking environment variables for password.</p> required <p>Returns:</p> Type Description <code>Optional[D2SpySession]</code> <p>Optional[D2SpySession]: Session with user access cookie.</p> Source code in <code>d2spy/auth.py</code> <pre><code>def login(\n    self,\n    email: Optional[str] = None,\n    password: Optional[str] = None,\n    skip_env: bool = False,\n) -&gt; Optional[D2SpySession]:\n    \"\"\"Login to D2S platform with email and password. Alternatively, use\n    environment variables `D2S_EMAIL` and `D2S_PASSWORD` to set email and password.\n    If the password is not passed as an argument and `D2S_PASSWORD` is not set,\n    `getpass` will be used to prompt user for password.\n\n    Args:\n        email Optional[str]: Email address used to sign in to D2S.\n        password Optional[str]: Password used to sign in to D2S.\n        skip_env bool: Skip checking environment variables for password.\n\n    Returns:\n        Optional[D2SpySession]: Session with user access cookie.\n    \"\"\"\n    # Check for email environment variable if not provided as argument\n    if not email:\n        email = os.environ.get(\"D2S_EMAIL\")\n        if not email:\n            raise ValueError(\n                \"Must provide 'email' to login method as argument or set email \"\n                \"as environment variable 'D2S_EMAIL'\"\n            )\n    # Check for password environment variable if not provided as argument\n    if not password:\n        password = os.environ.get(\"D2S_PASSWORD\")\n        # Request password from user if not set as environment variable\n        if not password or (password and skip_env):\n            password = getpass.getpass(prompt=\"Enter your D2S password:\")\n    # Credentials that will be sent to D2S auth API\n    credentials = {\"username\": email, \"password\": password}\n    # URL for D2S access-token endpoint\n    url = f\"{self.base_url}/api/v1/auth/access-token\"\n    # Post credentials to access-token endpoint\n    response = requests.post(url, data=credentials)\n    # JWT access token returned for successful request\n    if response.status_code == 200 and \"access_token\" in response.cookies:\n        # Normalize cookies to be scoped to the API host to avoid duplicates\n        host = urlparse(self.base_url).hostname or \"\"\n        token_value = response.cookies[\"access_token\"]\n        # Don't set explicit domain for localhost to avoid port-matching issues\n        if host == \"localhost\" or host == \"127.0.0.1\":\n            self.session.cookies.set(\n                \"access_token\",\n                token_value,\n                path=\"/\",\n            )\n        else:\n            self.session.cookies.set(\n                \"access_token\",\n                token_value,\n                domain=host,\n                path=\"/\",\n            )\n        if \"refresh_token\" in response.cookies:\n            refresh_value = response.cookies[\"refresh_token\"]\n            # Don't set explicit domain for localhost to avoid port-matching issues\n            if host == \"localhost\" or host == \"127.0.0.1\":\n                self.session.cookies.set(\n                    \"refresh_token\",\n                    refresh_value,\n                    path=\"/\",\n                )\n            else:\n                self.session.cookies.set(\n                    \"refresh_token\",\n                    refresh_value,\n                    domain=host,\n                    path=\"/\",\n                )\n        # Fetch user object associated with access token\n        user = self.get_current_user()\n        # Return dictionary of user attributes and values\n        if user:\n            # Check if user has api key and set it to session header if so\n            if hasattr(user, \"api_access_token\") and user.api_access_token:\n                self.session.d2s_data = {\"API_KEY\": user.api_access_token}\n            return self.session\n        else:\n            return None\n    elif response.status_code == 401:\n        self.login(email, password=None, skip_env=True)\n        return None\n    else:\n        # Print response if request fails\n        pretty_print_response(response)\n        return None\n</code></pre>"},{"location":"auth/#d2spy.auth.Auth.logout","title":"<code>logout()</code>","text":"<p>Logout of D2S platform.</p> Source code in <code>d2spy/auth.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Logout of D2S platform.\"\"\"\n    # Delete access-token and refresh-token cookies from session and end session\n    # Clear all cookies to avoid domain-matching issues\n    # (cookies may be stored with different domains depending on host type)\n    for cookie in list(self.session.cookies):\n        if cookie.name in [\"access_token\", \"refresh_token\"]:\n            self.session.cookies.clear(cookie.domain, cookie.path, cookie.name)\n    self.session.close()\n    print(\"session ended\")\n</code></pre>"},{"location":"conferences/","title":"Conferences","text":""},{"location":"data_product/","title":"data_product module","text":"Source code in <code>d2spy/models/data_product.py</code> <pre><code>class DataProduct:\n    id: UUID\n    data_type: str\n    filepath: str\n    original_filename: str\n    is_active: bool\n    flight_id: UUID\n    deactivated_at: Optional[datetime]\n    public: bool\n    stac_properties: STACProperties\n    status: str\n    url: str\n    # Optional fields for additional metadata\n    bbox: Optional[List[float]] = None\n    crs: Optional[Dict] = None\n    resolution: Optional[Dict] = None\n\n    def __init__(self, client: APIClient, **kwargs):\n        self.client = client\n        # data product attributes returned from API\n        self.__dict__.update(kwargs)\n\n    def __repr__(self):\n        return (\n            f\"DataProduct(data_type={self.data_type!r}, \"\n            f\"filepath={self.filepath!r}, \"\n            f\"original_filename={self.original_filename!r}, \"\n            f\"is_active={self.is_active!r}, public={self.public!r}, \"\n            f\"stac_properties={self.stac_properties!r}, status={self.status!r}, \"\n            f\"url={self.url!r}, bbox={self.bbox!r}, crs={self.crs!r}, \"\n            f\"resolution={self.resolution!r})\"\n        )\n\n    def clip(\n        self, geojson_feature: Dict[Any, Any], out_raster: str, export_vrt: bool = False\n    ) -&gt; bool:\n        \"\"\"Clips data product by GeoJSON Polygon Feature.\n\n        Requires: pip install d2spy[geo]\n\n        Args:\n            geojson_feature (Dict[Any, Any]): GeoJSON Polygon Feature.\n            out_raster (str): Path for output raster.\n            export_vrt (bool): Export VRT file.\n\n        Returns:\n            bool: True if successful. False if clip fails.\n        \"\"\"\n        if self.data_type == \"point_cloud\":\n            logger.error(\"Not available for point clouds\")\n            return False\n\n        # Lazy import to avoid requiring geo extras for core functionality\n        clip_by_mask = _lazy_import_clip_by_mask()\n\n        try:\n            clip_by_mask(self.url, geojson_feature, out_raster, export_vrt)\n            return True\n        except RasterioIOError as e:\n            if str(e) == \"HTTP response code: 401\":\n                if os.environ.get(\"D2S_API_KEY\"):\n                    try:\n                        url_with_key = (\n                            self.url + \"?API_KEY=\" + os.environ[\"D2S_API_KEY\"]\n                        )\n                        clip_by_mask(\n                            url_with_key,\n                            geojson_feature,\n                            out_raster,\n                            export_vrt,\n                        )\n                        return True\n                    except RasterioIOError as e2:\n                        if str(e2) == \"HTTP response code: 401\":\n                            logger.error(\n                                \"You do not have permission to access this raster\"\n                            )\n                            return False\n                        else:\n                            raise e2\n                else:\n                    logger.error(\n                        \"Set the 'D2S_API_KEY' environment variable before clipping\"\n                    )\n                    return False\n            else:\n                raise e\n        except Exception as e:\n            logger.error(f\"Failed to clip raster: {e}\")\n            return False\n\n    def get_band_info(self) -&gt; Optional[List[STACEOProperties]]:\n        \"\"\"Return STAC Electro-Optical bands information.\n\n        Returns:\n            Optional[List[STACEOProperties]]: _description_\n        \"\"\"\n        if self.data_type == \"point_cloud\":\n            logger.error(\"Point cloud does not have band info\")\n            return None\n\n        if not self.stac_properties.get(\"eo\"):\n            logger.error(\"Missing band properties\")\n            return None\n\n        eo_properties = self.stac_properties[\"eo\"]\n\n        if not isinstance(eo_properties, List):\n            logger.error(\"Band properties in unexpected format\")\n            return None\n\n        return eo_properties\n\n    def update_band_info(\n        self, band_info: List[STACEOProperties]\n    ) -&gt; Optional[List[STACEOProperties]]:\n        \"\"\"Update current band description information. Only the \"description\"\n        values may be updated. The \"name\" values must remain the same. You do\n        not need to include all bands in `band_info`, only the ones you wish to\n        update.\n\n        Args:\n            band_info (List[STACEOProperties]): Band info with new descriptions.\n\n        Returns:\n            Optional[List[STACEOProperties]]: Updated band info.\n        \"\"\"\n        # Match project ID from data product's URL\n        match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n        # Extract matched project ID\n        if match:\n            project_id = match.group(1)\n        else:\n            logger.error(\"Unable to find project ID associated with data product\")\n            return None\n\n        # Prepare endpoint for put request\n        endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n        endpoint += f\"/data_products/{self.id}/bands\"\n\n        # Construct payload\n        data = {\"bands\": band_info}\n\n        # Put form data\n        response_data = self.client.make_put_request(endpoint, json=data)\n\n        # Create the updated_data_product dictionary\n        updated_data_product = schemas.DataProduct.from_dict(response_data).__dict__\n\n        # Update the attributes of self\n        for key, value in updated_data_product.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                logger.warning(\n                    f\"Warning: Attribute '{key}' not found in DataProduct class.\"\n                )\n\n        # Create new DataProduct and return updated band info\n        return models.DataProduct(self.client, **updated_data_product).get_band_info()\n\n    def _get_default_tools_payload(self) -&gt; Dict[str, Any]:\n        \"\"\"Return default payload for data product tools API.\n\n        Returns:\n            Dict[str, Any]: Default payload dictionary.\n        \"\"\"\n        return {\n            \"chm\": False,\n            \"chmResolution\": 0.1,\n            \"chmPercentile\": 100,\n            \"dem_id\": \"\",\n            \"dtm\": False,\n            \"dtmResolution\": 0.1,\n            \"dtmRigidness\": 1,\n            \"exg\": False,\n            \"exgRed\": 0,\n            \"exgGreen\": 0,\n            \"exgBlue\": 0,\n            \"hillshade\": False,\n            \"ndvi\": False,\n            \"ndviNIR\": 0,\n            \"ndviRed\": 0,\n            \"vari\": False,\n            \"variRed\": 0,\n            \"variGreen\": 0,\n            \"variBlue\": 0,\n            \"zonal\": True,\n            \"zonal_layer_id\": \"\",\n        }\n\n    def derive_ndvi(self, red_band_idx: int, nir_band_idx: int) -&gt; bool:\n        \"\"\"Use data product's bands to derive a new NDVI data product. Must provide\n        the red and NIR band indexes.\n\n        Args:\n            red_band_idx (int): Red band index.\n            nir_band_idx (int): NIR band index.\n\n        Returns:\n            bool: True if the job was added to the queue, otherwise False.\n        \"\"\"\n        # Check if this is a raster data product\n        if (\n            self.data_type == \"point_cloud\"\n            or self.data_type == \"panoramic\"\n            or self.data_type == \"3dgs\"\n        ):\n            logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n            return False\n\n        # Get band properties from STAC EO extension\n        eo_properties = self.get_band_info()\n\n        # Check if the data product has at least two bands\n        if not isinstance(eo_properties, List) or len(eo_properties) &lt; 2:\n            logger.error(\"Data product must have at least two bands - Red and NIR\")\n            logger.error(eo_properties)\n            return False\n\n        # Reject if the red band index and NIR band index are the same\n        if red_band_idx == nir_band_idx:\n            logger.error(\"Red band index and NIR band index cannot be the same\")\n\n        # Reject if the red band is outside of the range of possible bands\n        if red_band_idx + 1 &gt; len(eo_properties) or red_band_idx &lt; 1:\n            logger.error(\"Red band index outside the range of available bands\")\n\n        # Reject if the NIR band is outside of the range of possible bands\n        if nir_band_idx + 1 &gt; len(eo_properties) or nir_band_idx &lt; 1:\n            logger.error(\"NIR band index outside the range of available bands\")\n\n        # Prepare payload for post request\n        data = self._get_default_tools_payload()\n        data.update(\n            {\n                \"ndvi\": True,\n                \"ndviNIR\": nir_band_idx,\n                \"ndviRed\": red_band_idx,\n            }\n        )\n\n        # Match project ID from data product's URL\n        match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n        # Extract matched project ID\n        if match:\n            project_id = match.group(1)\n        else:\n            logger.error(\"Unable to find project ID associated with data product\")\n            return False\n\n        # Prepare endpoint for post request\n        endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n        endpoint += f\"/data_products/{self.id}/tools\"\n\n        # post form data\n        self.client.make_post_request(endpoint, json=data)\n\n        logger.info(\"Job request has been added to the queue\")\n\n        return True\n\n    def derive_exg(\n        self, red_band_idx: int, green_band_idx: int, blue_band_idx: int\n    ) -&gt; bool:\n        \"\"\"Use data product's bands to derive a new Excess Green Index data product.\n        Must provide the red, green, and blue band indexes.\n\n        Args:\n            red_band_idx (int): Red band index.\n            green_band_idx (int): Green band index.\n            blue_band_idx (int): Blue band index.\n\n        Returns:\n            bool: True if the job was added to the queue, otherwise False.\n        \"\"\"\n        # Check if this is a raster data product\n        if (\n            self.data_type == \"point_cloud\"\n            or self.data_type == \"panoramic\"\n            or self.data_type == \"3dgs\"\n        ):\n            logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n            return False\n\n        # Get band properties from STAC EO extension\n        eo_properties = self.get_band_info()\n\n        # Check if the data product has at least two bands\n        if not isinstance(eo_properties, List) or len(eo_properties) &lt; 3:\n            logger.error(\n                \"Data product must have at least three bands - Red, Green, and Blue\"\n            )\n            logger.error(eo_properties)\n            return False\n\n        # Reject if any of the band indexes are the same\n        if len({red_band_idx, green_band_idx, blue_band_idx}) &lt; 3:\n            logger.error(\"Each band index must be unique\")\n\n        # Reject if the red band is outside of the range of possible bands\n        if red_band_idx + 1 &gt; len(eo_properties) or red_band_idx &lt; 1:\n            logger.error(\"Red band index outside the range of available bands\")\n\n        # Reject if the green band is outside of the range of possible bands\n        if green_band_idx + 1 &gt; len(eo_properties) or green_band_idx &lt; 1:\n            logger.error(\"Green band index outside the range of available bands\")\n\n        # Reject if the blue band is outside of the range of possible bands\n        if blue_band_idx + 1 &gt; len(eo_properties) or blue_band_idx &lt; 1:\n            logger.error(\"Blue band index outside the range of available bands\")\n\n        # Prepare payload for post request\n        data = self._get_default_tools_payload()\n        data.update(\n            {\n                \"exg\": True,\n                \"exgRed\": red_band_idx,\n                \"exgGreen\": green_band_idx,\n                \"exgBlue\": blue_band_idx,\n            }\n        )\n\n        # Match project ID from data product's URL\n        match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n        # Extract matched project ID\n        if match:\n            project_id = match.group(1)\n        else:\n            logger.error(\"Unable to find project ID associated with data product\")\n            return False\n\n        # Prepare endpoint for post request\n        endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n        endpoint += f\"/data_products/{self.id}/tools\"\n\n        # post form data\n        self.client.make_post_request(endpoint, json=data)\n\n        logger.info(\"Job request has been added to the queue\")\n\n        return True\n\n    def _fetch_zonal_statistics(\n        self, zonal_layer_id: str, project_id: str\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Internal method to fetch existing zonal statistics\n        (GET only, no job submission).\n\n        Args:\n            zonal_layer_id (str): ID of zonal layer.\n            project_id (str): Project ID.\n\n        Returns:\n            Optional[Dict[str, Any]]: Existing zonal statistics as GeoJSON dict, or None\n                if not found.\n        \"\"\"\n        # Prepare endpoint for get request\n        endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n        endpoint += (\n            f\"/data_products/{self.id}/zonal_statistics?layer_id={zonal_layer_id}\"\n        )\n\n        # Get zonal statistics - trust backend returns valid GeoJSON\n        response_data = self.client.make_get_request(endpoint)\n        if not response_data:\n            return None\n\n        # Return raw GeoJSON dict if it has features\n        if isinstance(response_data, dict) and response_data.get(\"features\"):\n            return response_data\n\n        return None\n\n    def get_zonal_statistics(\n        self,\n        zonal_layer_id: str,\n        wait: bool = True,\n        timeout: int = 300,\n        poll_interval: int = 5,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Generate and/or retrieve zonal statistics for a data product.\n\n        Args:\n            zonal_layer_id (str): ID of zonal layer.\n            wait (bool): If True and statistics don't exist, submit job and\n                poll for results. If False, submit job but return immediately.\n                Defaults to True.\n            timeout (int): Maximum seconds to wait for results (only used if wait=True).\n                Defaults to 300 seconds (5 minutes).\n            poll_interval (int): Seconds between polling attempts\n                (only used if wait=True). Defaults to 5 seconds.\n\n        Returns:\n            Optional[Dict[str, Any]]: Zonal statistics as GeoJSON dict, or None.\n        \"\"\"\n        # Check if the data product is a raster\n        if (\n            self.data_type == \"point_cloud\"\n            or self.data_type == \"panoramic\"\n            or self.data_type == \"3dgs\"\n        ):\n            logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n            return None\n\n        # Check if the data product has a single band\n        eo_properties = self.get_band_info()\n        if not isinstance(eo_properties, List) or len(eo_properties) &lt; 1:\n            logger.error(\"Data product must have at least one band\")\n            return None\n\n        if isinstance(eo_properties, List) and len(eo_properties) &gt; 1:\n            logger.error(\"Data product must have a single band\")\n            return None\n\n        # Match project ID from data product's URL\n        match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n        # Extract matched project ID\n        if not match:\n            logger.error(\"Unable to find project ID associated with data product\")\n            return None\n\n        project_id = match.group(1)\n\n        # Check if statistics already exist\n        feature_collection = self._fetch_zonal_statistics(zonal_layer_id, project_id)\n        if feature_collection:\n            return feature_collection\n\n        # Statistics don't exist - submit job\n        logger.info(\"No zonal statistics found - submitting job to generate new ones\")\n        if not self.generate_zonal_statistics(zonal_layer_id):\n            logger.error(\"Failed to submit job to generate zonal statistics\")\n            return None\n\n        # If not waiting, return early\n        if not wait:\n            logger.info(\n                \"Job submitted. Call get_zonal_statistics() again to retrieve results.\"\n            )\n            return None\n\n        # Poll for results\n        logger.info(\n            f\"Waiting for zonal statistics (timeout: {timeout}s, checking \"\n            f\"every {poll_interval}s)...\"\n        )\n        elapsed = 0\n\n        while elapsed &lt; timeout:\n            time.sleep(poll_interval)\n            elapsed += poll_interval\n\n            feature_collection = self._fetch_zonal_statistics(\n                zonal_layer_id, project_id\n            )\n            if feature_collection:\n                logger.info(f\"Zonal statistics ready after {elapsed}s\")\n                return feature_collection\n\n            logger.debug(f\"Still waiting... ({elapsed}s elapsed)\")\n\n        logger.warning(\n            f\"Timeout reached after {timeout}s. Statistics may still be processing.\"\n        )\n        logger.info(\"Call get_zonal_statistics() again later to retrieve results.\")\n        return None\n\n    def generate_zonal_statistics(self, zonal_layer_id: str) -&gt; bool:\n        \"\"\"Generate zonal statistics for a data product.\n\n        Args:\n            zonal_layer_id (str): ID of zonal layer.\n\n        Returns:\n            bool: True if the job was added to the queue, otherwise False.\n        \"\"\"\n        # Prepare payload for post request\n        data = self._get_default_tools_payload()\n        data.update(\n            {\n                \"dem_id\": str(self.id),\n                \"zonal_layer_id\": zonal_layer_id,\n            }\n        )\n\n        # Match project ID from data product's URL\n        match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n        # Extract matched project ID\n        if match:\n            project_id = match.group(1)\n        else:\n            logger.error(\"Unable to find project ID associated with data product\")\n            return False\n\n        # Prepare endpoint for post request\n        endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n        endpoint += f\"/data_products/{self.id}/tools\"\n\n        # post form data\n        self.client.make_post_request(endpoint, json=data)\n\n        return True\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.clip","title":"<code>clip(geojson_feature, out_raster, export_vrt=False)</code>","text":"<p>Clips data product by GeoJSON Polygon Feature.</p> <p>Requires: pip install d2spy[geo]</p> <p>Parameters:</p> Name Type Description Default <code>geojson_feature</code> <code>Dict[Any, Any]</code> <p>GeoJSON Polygon Feature.</p> required <code>out_raster</code> <code>str</code> <p>Path for output raster.</p> required <code>export_vrt</code> <code>bool</code> <p>Export VRT file.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful. False if clip fails.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def clip(\n    self, geojson_feature: Dict[Any, Any], out_raster: str, export_vrt: bool = False\n) -&gt; bool:\n    \"\"\"Clips data product by GeoJSON Polygon Feature.\n\n    Requires: pip install d2spy[geo]\n\n    Args:\n        geojson_feature (Dict[Any, Any]): GeoJSON Polygon Feature.\n        out_raster (str): Path for output raster.\n        export_vrt (bool): Export VRT file.\n\n    Returns:\n        bool: True if successful. False if clip fails.\n    \"\"\"\n    if self.data_type == \"point_cloud\":\n        logger.error(\"Not available for point clouds\")\n        return False\n\n    # Lazy import to avoid requiring geo extras for core functionality\n    clip_by_mask = _lazy_import_clip_by_mask()\n\n    try:\n        clip_by_mask(self.url, geojson_feature, out_raster, export_vrt)\n        return True\n    except RasterioIOError as e:\n        if str(e) == \"HTTP response code: 401\":\n            if os.environ.get(\"D2S_API_KEY\"):\n                try:\n                    url_with_key = (\n                        self.url + \"?API_KEY=\" + os.environ[\"D2S_API_KEY\"]\n                    )\n                    clip_by_mask(\n                        url_with_key,\n                        geojson_feature,\n                        out_raster,\n                        export_vrt,\n                    )\n                    return True\n                except RasterioIOError as e2:\n                    if str(e2) == \"HTTP response code: 401\":\n                        logger.error(\n                            \"You do not have permission to access this raster\"\n                        )\n                        return False\n                    else:\n                        raise e2\n            else:\n                logger.error(\n                    \"Set the 'D2S_API_KEY' environment variable before clipping\"\n                )\n                return False\n        else:\n            raise e\n    except Exception as e:\n        logger.error(f\"Failed to clip raster: {e}\")\n        return False\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.derive_exg","title":"<code>derive_exg(red_band_idx, green_band_idx, blue_band_idx)</code>","text":"<p>Use data product's bands to derive a new Excess Green Index data product. Must provide the red, green, and blue band indexes.</p> <p>Parameters:</p> Name Type Description Default <code>red_band_idx</code> <code>int</code> <p>Red band index.</p> required <code>green_band_idx</code> <code>int</code> <p>Green band index.</p> required <code>blue_band_idx</code> <code>int</code> <p>Blue band index.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the job was added to the queue, otherwise False.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def derive_exg(\n    self, red_band_idx: int, green_band_idx: int, blue_band_idx: int\n) -&gt; bool:\n    \"\"\"Use data product's bands to derive a new Excess Green Index data product.\n    Must provide the red, green, and blue band indexes.\n\n    Args:\n        red_band_idx (int): Red band index.\n        green_band_idx (int): Green band index.\n        blue_band_idx (int): Blue band index.\n\n    Returns:\n        bool: True if the job was added to the queue, otherwise False.\n    \"\"\"\n    # Check if this is a raster data product\n    if (\n        self.data_type == \"point_cloud\"\n        or self.data_type == \"panoramic\"\n        or self.data_type == \"3dgs\"\n    ):\n        logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n        return False\n\n    # Get band properties from STAC EO extension\n    eo_properties = self.get_band_info()\n\n    # Check if the data product has at least two bands\n    if not isinstance(eo_properties, List) or len(eo_properties) &lt; 3:\n        logger.error(\n            \"Data product must have at least three bands - Red, Green, and Blue\"\n        )\n        logger.error(eo_properties)\n        return False\n\n    # Reject if any of the band indexes are the same\n    if len({red_band_idx, green_band_idx, blue_band_idx}) &lt; 3:\n        logger.error(\"Each band index must be unique\")\n\n    # Reject if the red band is outside of the range of possible bands\n    if red_band_idx + 1 &gt; len(eo_properties) or red_band_idx &lt; 1:\n        logger.error(\"Red band index outside the range of available bands\")\n\n    # Reject if the green band is outside of the range of possible bands\n    if green_band_idx + 1 &gt; len(eo_properties) or green_band_idx &lt; 1:\n        logger.error(\"Green band index outside the range of available bands\")\n\n    # Reject if the blue band is outside of the range of possible bands\n    if blue_band_idx + 1 &gt; len(eo_properties) or blue_band_idx &lt; 1:\n        logger.error(\"Blue band index outside the range of available bands\")\n\n    # Prepare payload for post request\n    data = self._get_default_tools_payload()\n    data.update(\n        {\n            \"exg\": True,\n            \"exgRed\": red_band_idx,\n            \"exgGreen\": green_band_idx,\n            \"exgBlue\": blue_band_idx,\n        }\n    )\n\n    # Match project ID from data product's URL\n    match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n    # Extract matched project ID\n    if match:\n        project_id = match.group(1)\n    else:\n        logger.error(\"Unable to find project ID associated with data product\")\n        return False\n\n    # Prepare endpoint for post request\n    endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n    endpoint += f\"/data_products/{self.id}/tools\"\n\n    # post form data\n    self.client.make_post_request(endpoint, json=data)\n\n    logger.info(\"Job request has been added to the queue\")\n\n    return True\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.derive_ndvi","title":"<code>derive_ndvi(red_band_idx, nir_band_idx)</code>","text":"<p>Use data product's bands to derive a new NDVI data product. Must provide the red and NIR band indexes.</p> <p>Parameters:</p> Name Type Description Default <code>red_band_idx</code> <code>int</code> <p>Red band index.</p> required <code>nir_band_idx</code> <code>int</code> <p>NIR band index.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the job was added to the queue, otherwise False.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def derive_ndvi(self, red_band_idx: int, nir_band_idx: int) -&gt; bool:\n    \"\"\"Use data product's bands to derive a new NDVI data product. Must provide\n    the red and NIR band indexes.\n\n    Args:\n        red_band_idx (int): Red band index.\n        nir_band_idx (int): NIR band index.\n\n    Returns:\n        bool: True if the job was added to the queue, otherwise False.\n    \"\"\"\n    # Check if this is a raster data product\n    if (\n        self.data_type == \"point_cloud\"\n        or self.data_type == \"panoramic\"\n        or self.data_type == \"3dgs\"\n    ):\n        logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n        return False\n\n    # Get band properties from STAC EO extension\n    eo_properties = self.get_band_info()\n\n    # Check if the data product has at least two bands\n    if not isinstance(eo_properties, List) or len(eo_properties) &lt; 2:\n        logger.error(\"Data product must have at least two bands - Red and NIR\")\n        logger.error(eo_properties)\n        return False\n\n    # Reject if the red band index and NIR band index are the same\n    if red_band_idx == nir_band_idx:\n        logger.error(\"Red band index and NIR band index cannot be the same\")\n\n    # Reject if the red band is outside of the range of possible bands\n    if red_band_idx + 1 &gt; len(eo_properties) or red_band_idx &lt; 1:\n        logger.error(\"Red band index outside the range of available bands\")\n\n    # Reject if the NIR band is outside of the range of possible bands\n    if nir_band_idx + 1 &gt; len(eo_properties) or nir_band_idx &lt; 1:\n        logger.error(\"NIR band index outside the range of available bands\")\n\n    # Prepare payload for post request\n    data = self._get_default_tools_payload()\n    data.update(\n        {\n            \"ndvi\": True,\n            \"ndviNIR\": nir_band_idx,\n            \"ndviRed\": red_band_idx,\n        }\n    )\n\n    # Match project ID from data product's URL\n    match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n    # Extract matched project ID\n    if match:\n        project_id = match.group(1)\n    else:\n        logger.error(\"Unable to find project ID associated with data product\")\n        return False\n\n    # Prepare endpoint for post request\n    endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n    endpoint += f\"/data_products/{self.id}/tools\"\n\n    # post form data\n    self.client.make_post_request(endpoint, json=data)\n\n    logger.info(\"Job request has been added to the queue\")\n\n    return True\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.generate_zonal_statistics","title":"<code>generate_zonal_statistics(zonal_layer_id)</code>","text":"<p>Generate zonal statistics for a data product.</p> <p>Parameters:</p> Name Type Description Default <code>zonal_layer_id</code> <code>str</code> <p>ID of zonal layer.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the job was added to the queue, otherwise False.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def generate_zonal_statistics(self, zonal_layer_id: str) -&gt; bool:\n    \"\"\"Generate zonal statistics for a data product.\n\n    Args:\n        zonal_layer_id (str): ID of zonal layer.\n\n    Returns:\n        bool: True if the job was added to the queue, otherwise False.\n    \"\"\"\n    # Prepare payload for post request\n    data = self._get_default_tools_payload()\n    data.update(\n        {\n            \"dem_id\": str(self.id),\n            \"zonal_layer_id\": zonal_layer_id,\n        }\n    )\n\n    # Match project ID from data product's URL\n    match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n    # Extract matched project ID\n    if match:\n        project_id = match.group(1)\n    else:\n        logger.error(\"Unable to find project ID associated with data product\")\n        return False\n\n    # Prepare endpoint for post request\n    endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n    endpoint += f\"/data_products/{self.id}/tools\"\n\n    # post form data\n    self.client.make_post_request(endpoint, json=data)\n\n    return True\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.get_band_info","title":"<code>get_band_info()</code>","text":"<p>Return STAC Electro-Optical bands information.</p> <p>Returns:</p> Type Description <code>Optional[List[STACEOProperties]]</code> <p>Optional[List[STACEOProperties]]: description</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def get_band_info(self) -&gt; Optional[List[STACEOProperties]]:\n    \"\"\"Return STAC Electro-Optical bands information.\n\n    Returns:\n        Optional[List[STACEOProperties]]: _description_\n    \"\"\"\n    if self.data_type == \"point_cloud\":\n        logger.error(\"Point cloud does not have band info\")\n        return None\n\n    if not self.stac_properties.get(\"eo\"):\n        logger.error(\"Missing band properties\")\n        return None\n\n    eo_properties = self.stac_properties[\"eo\"]\n\n    if not isinstance(eo_properties, List):\n        logger.error(\"Band properties in unexpected format\")\n        return None\n\n    return eo_properties\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.get_zonal_statistics","title":"<code>get_zonal_statistics(zonal_layer_id, wait=True, timeout=300, poll_interval=5)</code>","text":"<p>Generate and/or retrieve zonal statistics for a data product.</p> <p>Parameters:</p> Name Type Description Default <code>zonal_layer_id</code> <code>str</code> <p>ID of zonal layer.</p> required <code>wait</code> <code>bool</code> <p>If True and statistics don't exist, submit job and poll for results. If False, submit job but return immediately. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Maximum seconds to wait for results (only used if wait=True). Defaults to 300 seconds (5 minutes).</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between polling attempts (only used if wait=True). Defaults to 5 seconds.</p> <code>5</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Zonal statistics as GeoJSON dict, or None.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def get_zonal_statistics(\n    self,\n    zonal_layer_id: str,\n    wait: bool = True,\n    timeout: int = 300,\n    poll_interval: int = 5,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Generate and/or retrieve zonal statistics for a data product.\n\n    Args:\n        zonal_layer_id (str): ID of zonal layer.\n        wait (bool): If True and statistics don't exist, submit job and\n            poll for results. If False, submit job but return immediately.\n            Defaults to True.\n        timeout (int): Maximum seconds to wait for results (only used if wait=True).\n            Defaults to 300 seconds (5 minutes).\n        poll_interval (int): Seconds between polling attempts\n            (only used if wait=True). Defaults to 5 seconds.\n\n    Returns:\n        Optional[Dict[str, Any]]: Zonal statistics as GeoJSON dict, or None.\n    \"\"\"\n    # Check if the data product is a raster\n    if (\n        self.data_type == \"point_cloud\"\n        or self.data_type == \"panoramic\"\n        or self.data_type == \"3dgs\"\n    ):\n        logger.error(\"Not available for point clouds, panoramic, or 3dgs\")\n        return None\n\n    # Check if the data product has a single band\n    eo_properties = self.get_band_info()\n    if not isinstance(eo_properties, List) or len(eo_properties) &lt; 1:\n        logger.error(\"Data product must have at least one band\")\n        return None\n\n    if isinstance(eo_properties, List) and len(eo_properties) &gt; 1:\n        logger.error(\"Data product must have a single band\")\n        return None\n\n    # Match project ID from data product's URL\n    match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n    # Extract matched project ID\n    if not match:\n        logger.error(\"Unable to find project ID associated with data product\")\n        return None\n\n    project_id = match.group(1)\n\n    # Check if statistics already exist\n    feature_collection = self._fetch_zonal_statistics(zonal_layer_id, project_id)\n    if feature_collection:\n        return feature_collection\n\n    # Statistics don't exist - submit job\n    logger.info(\"No zonal statistics found - submitting job to generate new ones\")\n    if not self.generate_zonal_statistics(zonal_layer_id):\n        logger.error(\"Failed to submit job to generate zonal statistics\")\n        return None\n\n    # If not waiting, return early\n    if not wait:\n        logger.info(\n            \"Job submitted. Call get_zonal_statistics() again to retrieve results.\"\n        )\n        return None\n\n    # Poll for results\n    logger.info(\n        f\"Waiting for zonal statistics (timeout: {timeout}s, checking \"\n        f\"every {poll_interval}s)...\"\n    )\n    elapsed = 0\n\n    while elapsed &lt; timeout:\n        time.sleep(poll_interval)\n        elapsed += poll_interval\n\n        feature_collection = self._fetch_zonal_statistics(\n            zonal_layer_id, project_id\n        )\n        if feature_collection:\n            logger.info(f\"Zonal statistics ready after {elapsed}s\")\n            return feature_collection\n\n        logger.debug(f\"Still waiting... ({elapsed}s elapsed)\")\n\n    logger.warning(\n        f\"Timeout reached after {timeout}s. Statistics may still be processing.\"\n    )\n    logger.info(\"Call get_zonal_statistics() again later to retrieve results.\")\n    return None\n</code></pre>"},{"location":"data_product/#d2spy.models.data_product.DataProduct.update_band_info","title":"<code>update_band_info(band_info)</code>","text":"<p>Update current band description information. Only the \"description\" values may be updated. The \"name\" values must remain the same. You do not need to include all bands in <code>band_info</code>, only the ones you wish to update.</p> <p>Parameters:</p> Name Type Description Default <code>band_info</code> <code>List[STACEOProperties]</code> <p>Band info with new descriptions.</p> required <p>Returns:</p> Type Description <code>Optional[List[STACEOProperties]]</code> <p>Optional[List[STACEOProperties]]: Updated band info.</p> Source code in <code>d2spy/models/data_product.py</code> <pre><code>def update_band_info(\n    self, band_info: List[STACEOProperties]\n) -&gt; Optional[List[STACEOProperties]]:\n    \"\"\"Update current band description information. Only the \"description\"\n    values may be updated. The \"name\" values must remain the same. You do\n    not need to include all bands in `band_info`, only the ones you wish to\n    update.\n\n    Args:\n        band_info (List[STACEOProperties]): Band info with new descriptions.\n\n    Returns:\n        Optional[List[STACEOProperties]]: Updated band info.\n    \"\"\"\n    # Match project ID from data product's URL\n    match = re.search(r\"/projects/([a-f0-9\\-]+)/\", self.url)\n\n    # Extract matched project ID\n    if match:\n        project_id = match.group(1)\n    else:\n        logger.error(\"Unable to find project ID associated with data product\")\n        return None\n\n    # Prepare endpoint for put request\n    endpoint = f\"/api/v1/projects/{project_id}/flights/{self.flight_id}\"\n    endpoint += f\"/data_products/{self.id}/bands\"\n\n    # Construct payload\n    data = {\"bands\": band_info}\n\n    # Put form data\n    response_data = self.client.make_put_request(endpoint, json=data)\n\n    # Create the updated_data_product dictionary\n    updated_data_product = schemas.DataProduct.from_dict(response_data).__dict__\n\n    # Update the attributes of self\n    for key, value in updated_data_product.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            logger.warning(\n                f\"Warning: Attribute '{key}' not found in DataProduct class.\"\n            )\n\n    # Create new DataProduct and return updated band info\n    return models.DataProduct(self.client, **updated_data_product).get_band_info()\n</code></pre>"},{"location":"data_product_collection/","title":"data_product_collection module","text":"<p>Collection of Data to Science data products associated with a flight.</p> Source code in <code>d2spy/models/data_product_collection.py</code> <pre><code>class DataProductCollection:\n    \"\"\"Collection of Data to Science data products associated with a flight.\"\"\"\n\n    def __init__(self, collection: List[DataProduct] = []):\n        self.collection = collection\n\n    def __getitem__(self, index: int) -&gt; DataProduct:\n        return self.collection[int(index)]\n\n    def __len__(self) -&gt; int:\n        return len(self.collection)\n\n    def __repr__(self) -&gt; str:\n        return f\"DataProductCollection({self.collection})\"\n\n    def filter_by_data_type(self, data_type: str) -&gt; \"DataProductCollection\":\n        \"\"\"Returns list of data products matching data type.\n\n        Args:\n            data_type (str): Data type to filter by.\n\n        Returns:\n            DataProductCollection: Collection of data products matching data type.\n        \"\"\"\n        filtered_collection = [\n            data_product\n            for data_product in self.collection\n            if data_product.data_type.lower() == data_type.lower()\n        ]\n        return DataProductCollection(collection=filtered_collection)\n</code></pre>"},{"location":"data_product_collection/#d2spy.models.data_product_collection.DataProductCollection.filter_by_data_type","title":"<code>filter_by_data_type(data_type)</code>","text":"<p>Returns list of data products matching data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Data type to filter by.</p> required <p>Returns:</p> Name Type Description <code>DataProductCollection</code> <code>DataProductCollection</code> <p>Collection of data products matching data type.</p> Source code in <code>d2spy/models/data_product_collection.py</code> <pre><code>def filter_by_data_type(self, data_type: str) -&gt; \"DataProductCollection\":\n    \"\"\"Returns list of data products matching data type.\n\n    Args:\n        data_type (str): Data type to filter by.\n\n    Returns:\n        DataProductCollection: Collection of data products matching data type.\n    \"\"\"\n    filtered_collection = [\n        data_product\n        for data_product in self.collection\n        if data_product.data_type.lower() == data_type.lower()\n    ]\n    return DataProductCollection(collection=filtered_collection)\n</code></pre>"},{"location":"flight/","title":"flight module","text":"Source code in <code>d2spy/models/flight.py</code> <pre><code>class Flight:\n    id: UUID\n    name: Optional[str]\n    acquisition_date: date\n    altitude: float\n    side_overlap: float\n    forward_overlap: float\n    sensor: str\n    platform: str\n    is_active: bool\n    deactivated_at: Optional[datetime]\n    project_id: UUID\n    pilot_id: UUID\n    data_products: List[DataProduct]\n\n    def __init__(self, client: APIClient, **kwargs):\n        self.client = client\n        # Flight attributes returned from API\n        self.__dict__.update(kwargs)\n\n    def __repr__(self):\n        return (\n            f\"Flight(acquisition_date={self.acquisition_date!r}, name={self.name!r}, \"\n            f\"altitude={self.altitude!r}, side_overlap={self.side_overlap!r}, \"\n            f\"forward_overlap={self.forward_overlap!r}, sensor={self.sensor!r}, \"\n            f\"platform={self.platform!r})\"\n        )\n\n    def add_data_product(\n        self,\n        filepath: str,\n        data_type: Union[Literal[\"dsm\", \"point_cloud\", \"ortho\"], str],\n    ) -&gt; None:\n        \"\"\"Uploads data product to D2S. After the upload finishes, the data product may\n        not be available for several minutes while it is processed on the D2S server. It\n        will be returned by `Flight.get_data_products` once ready.\n\n        Args:\n            filepath (str): Full path to data product on local file system.\n            data_type (Union[Literal[\"dsm\", \"point_cloud\", \"ortho\"], str]): Data type.\n        \"\"\"\n        verify_file_exists(filepath)\n        validate_file_extension_and_data_type(filepath, data_type)\n        # Ensure we have a fresh access token via existing refresh flow\n        self.client.make_get_request(\"/api/v1/users/current\")\n        # url for tusd server\n        endpoint = f\"{self.client.base_url}/files\"\n        # authorization cookie\n        cookies = {\"access_token\": self.client.session.cookies[\"access_token\"]}\n        # project, flight, data type headers\n        headers: Dict[str, str] = {\n            \"X-Project-ID\": str(self.project_id),\n            \"X-Flight-ID\": str(self.id),\n            \"X-Data-Type\": data_type,\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Origin\": self.client.base_url,\n        }\n        # metadata about data product file\n        metadata = {\n            \"filename\": Path(filepath).name,\n            \"filetype\": get_metadata_filetype(filepath),\n            \"name\": Path(filepath).name,\n            \"relativePath\": \"null\",\n            \"type\": get_metadata_filetype(filepath),\n        }\n        # create tus client and set headers and cookies\n        tus_client = tusc.TusClient(endpoint)\n        tus_client.set_headers(headers)\n        tus_client.set_cookies(cookies)\n        # create uploader for data product file with metadata\n        chunk_size = 10 * 1024 * 1024  # 10 MiB\n        tus_uploader = tus_client.uploader(\n            filepath, chunk_size=chunk_size, metadata=metadata\n        )\n        # upload in chunks and print progress\n        file_size = tus_uploader.get_file_size()\n        while tus_uploader.offset &lt; file_size:\n            tus_uploader.upload_chunk()\n            progress = (tus_uploader.offset / file_size) * 100\n            print(f\"Upload progress: {progress:.2f}%\", end=\"\\r\")\n\n    def add_raw_data(self, filepath: str) -&gt; None:\n        \"\"\"Uploads zipped raw data to D2S. After the upload finishes, the raw data may\n        not be available for several minutes while it is processed on the D2S server. It\n        will be returned by `Flight.get_raw_data` once ready.\n\n        Args:\n            filepath (str): Full path to data product on local file system.\n        \"\"\"\n        verify_file_exists(filepath)\n        validate_file_extension_for_raw_data(filepath)\n        # Ensure we have a fresh access token via existing refresh flow\n        self.client.make_get_request(\"/api/v1/users/current\")\n        # url for tusd server\n        endpoint = f\"{self.client.base_url}/files\"\n        # authorization cookie\n        cookies = {\"access_token\": self.client.session.cookies[\"access_token\"]}\n        # project, flight, data type headers\n        headers: Dict[str, str] = {\n            \"X-Project-ID\": str(self.project_id),\n            \"X-Flight-ID\": str(self.id),\n            \"X-Data-Type\": \"raw\",\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate, br, zstd\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n            \"Origin\": self.client.base_url,\n        }\n        # metadata about raw data file\n        metadata = {\n            \"filename\": Path(filepath).name,\n            \"filetype\": \"application/zip\",\n            \"name\": Path(filepath).name,\n            \"relativePath\": \"null\",\n            \"type\": \"application/zip\",\n        }\n        # create tus client and set headers and cookies\n        tus_client = tusc.TusClient(endpoint)\n        tus_client.set_headers(headers)\n        tus_client.set_cookies(cookies)\n        # create uploader for raw file with metadata\n        chunk_size = 10 * 1024 * 1024  # 10 MiB\n        tus_uploader = tus_client.uploader(\n            filepath, chunk_size=chunk_size, metadata=metadata\n        )\n        # upload in chunks and print progress\n        file_size = tus_uploader.get_file_size()\n        while tus_uploader.offset &lt; file_size:\n            tus_uploader.upload_chunk()\n            progress = (tus_uploader.offset / file_size) * 100\n            print(f\"Upload progress: {progress:.2f}%\", end=\"\\r\")\n\n    def get_data_product(self, data_product_id: str) -&gt; Optional[DataProduct]:\n        \"\"\"Request single data product by ID. Data product must be active\n        and viewable by user.\n\n        Args:\n            data_product_id (str): Data product ID.\n\n        Returns:\n            Optional[models.DataProduct]: Data product ID or None.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n        endpoint += f\"/data_products/{data_product_id}\"\n        response_data = self.client.make_get_request(endpoint)\n        response_data = ensure_dict(response_data)\n        data_product = schemas.DataProduct.from_dict(response_data)\n        return models.DataProduct(self.client, **data_product.__dict__)\n\n    def get_data_products(self) -&gt; DataProductCollection:\n        \"\"\"Return list of all active data products in a flight.\n\n        Returns:\n            DataProductCollection: Collection of data products.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}/data_products\"\n        response_data = self.client.make_get_request(endpoint)\n\n        data_products = [\n            models.DataProduct(\n                self.client,\n                **schemas.DataProduct.from_dict(data_product).__dict__,\n            )\n            for data_product in response_data\n        ]\n        return DataProductCollection(collection=data_products)\n\n    def get_raw_data(self) -&gt; List[models.RawData]:\n        \"\"\"Return list of all active raw data in a flight.\n\n        Returns:\n            List[models.RawData]: List of raw data.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}/raw_data\"\n        response_data = self.client.make_get_request(endpoint)\n\n        all_raw_data = [\n            models.RawData(\n                self.client,\n                **schemas.RawData.from_dict(raw_data).__dict__,\n            )\n            for raw_data in response_data\n        ]\n        return all_raw_data\n\n    def move_to_project(self, destination_project_id: UUID) -&gt; None:\n        \"\"\"Moves flight from its current project to different project. You must be an\n        owner of both the source project and destination project to make the transfer.\n\n        Args:\n            destination_project_id (UUID): ID of project the flight will be moved to.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n        endpoint += f\"/move_to_project/{destination_project_id}\"\n        response_data = self.client.make_put_request(endpoint)\n\n        updated_flight = schemas.Flight.from_dict(response_data).__dict__\n        for key, value in updated_flight.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                print(f\"Warning: Attribute '{key}' not found in Flight class.\")\n        return None\n\n    def update(self, **kwargs) -&gt; None:\n        \"\"\"Update flight attributes.\"\"\"\n        endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n        response_data = self.client.make_put_request(\n            endpoint, json=json.loads(json.dumps(kwargs, default=str))\n        )\n\n        updated_flight = schemas.Flight.from_dict(response_data).__dict__\n        for key, value in updated_flight.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                print(f\"Warning: Attribute '{key}' not found in Flight class.\")\n        return None\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.add_data_product","title":"<code>add_data_product(filepath, data_type)</code>","text":"<p>Uploads data product to D2S. After the upload finishes, the data product may not be available for several minutes while it is processed on the D2S server. It will be returned by <code>Flight.get_data_products</code> once ready.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Full path to data product on local file system.</p> required <code>data_type</code> <code>Union[Literal['dsm', 'point_cloud', 'ortho'], str]</code> <p>Data type.</p> required Source code in <code>d2spy/models/flight.py</code> <pre><code>def add_data_product(\n    self,\n    filepath: str,\n    data_type: Union[Literal[\"dsm\", \"point_cloud\", \"ortho\"], str],\n) -&gt; None:\n    \"\"\"Uploads data product to D2S. After the upload finishes, the data product may\n    not be available for several minutes while it is processed on the D2S server. It\n    will be returned by `Flight.get_data_products` once ready.\n\n    Args:\n        filepath (str): Full path to data product on local file system.\n        data_type (Union[Literal[\"dsm\", \"point_cloud\", \"ortho\"], str]): Data type.\n    \"\"\"\n    verify_file_exists(filepath)\n    validate_file_extension_and_data_type(filepath, data_type)\n    # Ensure we have a fresh access token via existing refresh flow\n    self.client.make_get_request(\"/api/v1/users/current\")\n    # url for tusd server\n    endpoint = f\"{self.client.base_url}/files\"\n    # authorization cookie\n    cookies = {\"access_token\": self.client.session.cookies[\"access_token\"]}\n    # project, flight, data type headers\n    headers: Dict[str, str] = {\n        \"X-Project-ID\": str(self.project_id),\n        \"X-Flight-ID\": str(self.id),\n        \"X-Data-Type\": data_type,\n        \"Accept-Language\": \"en-US,en;q=0.5\",\n        \"Origin\": self.client.base_url,\n    }\n    # metadata about data product file\n    metadata = {\n        \"filename\": Path(filepath).name,\n        \"filetype\": get_metadata_filetype(filepath),\n        \"name\": Path(filepath).name,\n        \"relativePath\": \"null\",\n        \"type\": get_metadata_filetype(filepath),\n    }\n    # create tus client and set headers and cookies\n    tus_client = tusc.TusClient(endpoint)\n    tus_client.set_headers(headers)\n    tus_client.set_cookies(cookies)\n    # create uploader for data product file with metadata\n    chunk_size = 10 * 1024 * 1024  # 10 MiB\n    tus_uploader = tus_client.uploader(\n        filepath, chunk_size=chunk_size, metadata=metadata\n    )\n    # upload in chunks and print progress\n    file_size = tus_uploader.get_file_size()\n    while tus_uploader.offset &lt; file_size:\n        tus_uploader.upload_chunk()\n        progress = (tus_uploader.offset / file_size) * 100\n        print(f\"Upload progress: {progress:.2f}%\", end=\"\\r\")\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.add_raw_data","title":"<code>add_raw_data(filepath)</code>","text":"<p>Uploads zipped raw data to D2S. After the upload finishes, the raw data may not be available for several minutes while it is processed on the D2S server. It will be returned by <code>Flight.get_raw_data</code> once ready.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Full path to data product on local file system.</p> required Source code in <code>d2spy/models/flight.py</code> <pre><code>def add_raw_data(self, filepath: str) -&gt; None:\n    \"\"\"Uploads zipped raw data to D2S. After the upload finishes, the raw data may\n    not be available for several minutes while it is processed on the D2S server. It\n    will be returned by `Flight.get_raw_data` once ready.\n\n    Args:\n        filepath (str): Full path to data product on local file system.\n    \"\"\"\n    verify_file_exists(filepath)\n    validate_file_extension_for_raw_data(filepath)\n    # Ensure we have a fresh access token via existing refresh flow\n    self.client.make_get_request(\"/api/v1/users/current\")\n    # url for tusd server\n    endpoint = f\"{self.client.base_url}/files\"\n    # authorization cookie\n    cookies = {\"access_token\": self.client.session.cookies[\"access_token\"]}\n    # project, flight, data type headers\n    headers: Dict[str, str] = {\n        \"X-Project-ID\": str(self.project_id),\n        \"X-Flight-ID\": str(self.id),\n        \"X-Data-Type\": \"raw\",\n        \"Accept\": \"*/*\",\n        \"Accept-Encoding\": \"gzip, deflate, br, zstd\",\n        \"Accept-Language\": \"en-US,en;q=0.5\",\n        \"Connection\": \"keep-alive\",\n        \"Origin\": self.client.base_url,\n    }\n    # metadata about raw data file\n    metadata = {\n        \"filename\": Path(filepath).name,\n        \"filetype\": \"application/zip\",\n        \"name\": Path(filepath).name,\n        \"relativePath\": \"null\",\n        \"type\": \"application/zip\",\n    }\n    # create tus client and set headers and cookies\n    tus_client = tusc.TusClient(endpoint)\n    tus_client.set_headers(headers)\n    tus_client.set_cookies(cookies)\n    # create uploader for raw file with metadata\n    chunk_size = 10 * 1024 * 1024  # 10 MiB\n    tus_uploader = tus_client.uploader(\n        filepath, chunk_size=chunk_size, metadata=metadata\n    )\n    # upload in chunks and print progress\n    file_size = tus_uploader.get_file_size()\n    while tus_uploader.offset &lt; file_size:\n        tus_uploader.upload_chunk()\n        progress = (tus_uploader.offset / file_size) * 100\n        print(f\"Upload progress: {progress:.2f}%\", end=\"\\r\")\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.get_data_product","title":"<code>get_data_product(data_product_id)</code>","text":"<p>Request single data product by ID. Data product must be active and viewable by user.</p> <p>Parameters:</p> Name Type Description Default <code>data_product_id</code> <code>str</code> <p>Data product ID.</p> required <p>Returns:</p> Type Description <code>Optional[DataProduct]</code> <p>Optional[models.DataProduct]: Data product ID or None.</p> Source code in <code>d2spy/models/flight.py</code> <pre><code>def get_data_product(self, data_product_id: str) -&gt; Optional[DataProduct]:\n    \"\"\"Request single data product by ID. Data product must be active\n    and viewable by user.\n\n    Args:\n        data_product_id (str): Data product ID.\n\n    Returns:\n        Optional[models.DataProduct]: Data product ID or None.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n    endpoint += f\"/data_products/{data_product_id}\"\n    response_data = self.client.make_get_request(endpoint)\n    response_data = ensure_dict(response_data)\n    data_product = schemas.DataProduct.from_dict(response_data)\n    return models.DataProduct(self.client, **data_product.__dict__)\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.get_data_products","title":"<code>get_data_products()</code>","text":"<p>Return list of all active data products in a flight.</p> <p>Returns:</p> Name Type Description <code>DataProductCollection</code> <code>DataProductCollection</code> <p>Collection of data products.</p> Source code in <code>d2spy/models/flight.py</code> <pre><code>def get_data_products(self) -&gt; DataProductCollection:\n    \"\"\"Return list of all active data products in a flight.\n\n    Returns:\n        DataProductCollection: Collection of data products.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}/data_products\"\n    response_data = self.client.make_get_request(endpoint)\n\n    data_products = [\n        models.DataProduct(\n            self.client,\n            **schemas.DataProduct.from_dict(data_product).__dict__,\n        )\n        for data_product in response_data\n    ]\n    return DataProductCollection(collection=data_products)\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.get_raw_data","title":"<code>get_raw_data()</code>","text":"<p>Return list of all active raw data in a flight.</p> <p>Returns:</p> Type Description <code>List[RawData]</code> <p>List[models.RawData]: List of raw data.</p> Source code in <code>d2spy/models/flight.py</code> <pre><code>def get_raw_data(self) -&gt; List[models.RawData]:\n    \"\"\"Return list of all active raw data in a flight.\n\n    Returns:\n        List[models.RawData]: List of raw data.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}/raw_data\"\n    response_data = self.client.make_get_request(endpoint)\n\n    all_raw_data = [\n        models.RawData(\n            self.client,\n            **schemas.RawData.from_dict(raw_data).__dict__,\n        )\n        for raw_data in response_data\n    ]\n    return all_raw_data\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.move_to_project","title":"<code>move_to_project(destination_project_id)</code>","text":"<p>Moves flight from its current project to different project. You must be an owner of both the source project and destination project to make the transfer.</p> <p>Parameters:</p> Name Type Description Default <code>destination_project_id</code> <code>UUID</code> <p>ID of project the flight will be moved to.</p> required Source code in <code>d2spy/models/flight.py</code> <pre><code>def move_to_project(self, destination_project_id: UUID) -&gt; None:\n    \"\"\"Moves flight from its current project to different project. You must be an\n    owner of both the source project and destination project to make the transfer.\n\n    Args:\n        destination_project_id (UUID): ID of project the flight will be moved to.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n    endpoint += f\"/move_to_project/{destination_project_id}\"\n    response_data = self.client.make_put_request(endpoint)\n\n    updated_flight = schemas.Flight.from_dict(response_data).__dict__\n    for key, value in updated_flight.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            print(f\"Warning: Attribute '{key}' not found in Flight class.\")\n    return None\n</code></pre>"},{"location":"flight/#d2spy.models.flight.Flight.update","title":"<code>update(**kwargs)</code>","text":"<p>Update flight attributes.</p> Source code in <code>d2spy/models/flight.py</code> <pre><code>def update(self, **kwargs) -&gt; None:\n    \"\"\"Update flight attributes.\"\"\"\n    endpoint = f\"/api/v1/projects/{self.project_id}/flights/{self.id}\"\n    response_data = self.client.make_put_request(\n        endpoint, json=json.loads(json.dumps(kwargs, default=str))\n    )\n\n    updated_flight = schemas.Flight.from_dict(response_data).__dict__\n    for key, value in updated_flight.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            print(f\"Warning: Attribute '{key}' not found in Flight class.\")\n    return None\n</code></pre>"},{"location":"flight_collection/","title":"flight_collection module","text":"<p>Collection of Data to Science flights associated with a project.</p> Source code in <code>d2spy/models/flight_collection.py</code> <pre><code>class FlightCollection:\n    \"\"\"Collection of Data to Science flights associated with a project.\"\"\"\n\n    def __init__(self, collection: List[Flight] = []):\n        self.collection = collection\n\n    def __getitem__(self, index: int) -&gt; Flight:\n        return self.collection[int(index)]\n\n    def __len__(self) -&gt; int:\n        return len(self.collection)\n\n    def __repr__(self) -&gt; str:\n        return f\"FlightCollection({self.collection})\"\n\n    def filter_by_date(self, start_date: date, end_date: date) -&gt; \"FlightCollection\":\n        \"\"\"Returns collection of flights within the acquisition date range.\n\n        Args:\n            start_date (date): Starting date for the flight acquisition date range.\n            end_date (date): Ending date for the flight acquisition date range.\n\n        Returns:\n            FlightCollection: Collection of flights within the acquisition date range.\n        \"\"\"\n        filtered_collection = [\n            flight\n            for flight in self.collection\n            if convert_from_str_to_date(flight.acquisition_date) &gt;= start_date\n            and convert_from_str_to_date(flight.acquisition_date) &lt;= end_date\n        ]\n        return FlightCollection(collection=filtered_collection)\n\n    def filter_by_sensor(self, sensor: str, exact: bool = False) -&gt; \"FlightCollection\":\n        \"\"\"Returns collection of flights with specified sensor.\n\n        Args:\n            sensor (str): Sensor of interest.\n            exact (bool, optional): Must be exact match. Defaults to False.\n\n        Returns:\n            FlightCollection: Collection of flights with matching sensor.\n        \"\"\"\n        filtered_collection = [\n            flight\n            for flight in self.collection\n            if is_match(sensor, flight.sensor, exact)\n        ]\n        return FlightCollection(collection=filtered_collection)\n</code></pre>"},{"location":"flight_collection/#d2spy.models.flight_collection.FlightCollection.filter_by_date","title":"<code>filter_by_date(start_date, end_date)</code>","text":"<p>Returns collection of flights within the acquisition date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date</code> <p>Starting date for the flight acquisition date range.</p> required <code>end_date</code> <code>date</code> <p>Ending date for the flight acquisition date range.</p> required <p>Returns:</p> Name Type Description <code>FlightCollection</code> <code>FlightCollection</code> <p>Collection of flights within the acquisition date range.</p> Source code in <code>d2spy/models/flight_collection.py</code> <pre><code>def filter_by_date(self, start_date: date, end_date: date) -&gt; \"FlightCollection\":\n    \"\"\"Returns collection of flights within the acquisition date range.\n\n    Args:\n        start_date (date): Starting date for the flight acquisition date range.\n        end_date (date): Ending date for the flight acquisition date range.\n\n    Returns:\n        FlightCollection: Collection of flights within the acquisition date range.\n    \"\"\"\n    filtered_collection = [\n        flight\n        for flight in self.collection\n        if convert_from_str_to_date(flight.acquisition_date) &gt;= start_date\n        and convert_from_str_to_date(flight.acquisition_date) &lt;= end_date\n    ]\n    return FlightCollection(collection=filtered_collection)\n</code></pre>"},{"location":"flight_collection/#d2spy.models.flight_collection.FlightCollection.filter_by_sensor","title":"<code>filter_by_sensor(sensor, exact=False)</code>","text":"<p>Returns collection of flights with specified sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>Sensor of interest.</p> required <code>exact</code> <code>bool</code> <p>Must be exact match. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>FlightCollection</code> <code>FlightCollection</code> <p>Collection of flights with matching sensor.</p> Source code in <code>d2spy/models/flight_collection.py</code> <pre><code>def filter_by_sensor(self, sensor: str, exact: bool = False) -&gt; \"FlightCollection\":\n    \"\"\"Returns collection of flights with specified sensor.\n\n    Args:\n        sensor (str): Sensor of interest.\n        exact (bool, optional): Must be exact match. Defaults to False.\n\n    Returns:\n        FlightCollection: Collection of flights with matching sensor.\n    \"\"\"\n    filtered_collection = [\n        flight\n        for flight in self.collection\n        if is_match(sensor, flight.sensor, exact)\n    ]\n    return FlightCollection(collection=filtered_collection)\n</code></pre>"},{"location":"guides/","title":"Guides","text":"<p>The following guides demonstrate how d2spy can be used to interact with an instance of the Data to Science application.</p> <ol> <li>Creating new projects and flights, and uploading raw data/data products (notebook)</li> <li>Accessing your workspace projects, flights, and data products (notebook)</li> <li>Adding multiple data products to a flight (notebook)</li> <li>Visualizing your data products using leafmap (notebook)</li> <li>Visualizing your projects using leafmap (notebook)</li> <li>Clipping a raster data project (notebook)</li> <li>3DEP search by D2S projects (notebook)</li> <li>3DEP search by polygon and clip with PDAL (notebook)</li> <li>NAIP search by D2S projects and clip (notebook)</li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>If your environment has at least Python 3.8+ installed and pip, you are ready to get started.</p> <p>Install d2spy from PyPi by running:</p> <pre><code>pip install d2spy\n</code></pre> <p>That's it. Head over to the Guides page to view examples of how to use d2spy or jump over to the API Reference section for a more in-depth look at the package.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Geospatial Data Science Lab</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"project/","title":"project module","text":"Source code in <code>d2spy/models/project.py</code> <pre><code>class Project:\n    id: UUID\n    deactivated_at: Optional[datetime]\n    description: str\n    field: ProjectBoundaryGeoJSON\n    flight_count: int\n    harvest_date: Optional[date]\n    is_active: bool\n    location_id: UUID\n    planting_date: Optional[date]\n    role: Literal[\"owner\", \"manager\", \"viewer\"]\n    team_id: Optional[UUID]\n    title: str\n\n    def __init__(self, client: APIClient, **kwargs):\n        self.client = client\n        # project attributes returned from API\n        self.__dict__.update(kwargs)\n\n    def __repr__(self):\n        repr_str = f\"Project(title={self.title!r}, description={self.description!r}\"\n\n        if hasattr(self, \"start_date\") and self.start_date:\n            repr_str += f\", start_date={self.start_date!r}\"\n\n        if hasattr(self, \"end_date\") and self.end_date:\n            repr_str += f\", end_date={self.end_date!r}\"\n\n        repr_str += \")\"\n\n        return repr_str\n\n    def add_flight(\n        self,\n        acquisition_date: date,\n        altitude: float,\n        side_overlap: float,\n        forward_overlap: float,\n        sensor: Literal[\"RGB\", \"Multispectral\", \"LiDAR\", \"Other\"],\n        platform: Union[Literal[\"Phantom_4\", \"M300\", \"M350\", \"Other\"], str],\n        name: Optional[str] = None,\n        pilot_id: Optional[UUID] = None,\n    ) -&gt; models.Flight:\n        \"\"\"Create new flight in a project.\n\n        Args:\n            name (Optional[str]): Name of flight.\n            acquisition_date (date): Date of flight.\n            altitude (float): Flight altitude.\n            side_overlap (float): Flight side overlap %.\n            forward_overlap (float): Flight forward overlap %.\n            sensor (Literal[\"RGB\", \"Multispectral\", \"LiDAR\", \"Other\"]): Camera sensor.\n            platform (Union[Literal[\"Phantom_4\", \"M300\", \"M350\"], str]): UAS platform.\n            pilot_id (Optional[UUID]): ID of the flight's pilot. Defaults to None.\n\n        Returns:\n            models.Flight: Newly created flight.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}/flights\"\n\n        # if pilot id not provided, use current user's id\n        if not pilot_id:\n            user = self.client.make_get_request(\"/api/v1/users/current\")\n            user = ensure_dict(user)\n            pilot_id = user[\"id\"]\n\n        # form data for flight creation\n        data = {\n            \"name\": name,\n            \"acquisition_date\": acquisition_date.strftime(\"%Y-%m-%d\"),\n            \"altitude\": altitude,\n            \"side_overlap\": side_overlap,\n            \"forward_overlap\": forward_overlap,\n            \"sensor\": sensor,\n            \"platform\": platform,\n            \"pilot_id\": pilot_id,\n        }\n\n        # post form data\n        response_data = self.client.make_post_request(endpoint, json=data)\n\n        # return flight model\n        flight = models.Flight(\n            self.client, **schemas.Flight.from_dict(response_data).__dict__\n        )\n        return flight\n\n    def add_map_layer(\n        self, layer_name: str, feature_collection: Dict[str, Any]\n    ) -&gt; MapLayerFeatureCollection:\n        \"\"\"Add vector map layer to a project.\n\n        Args:\n            layer_name (str): Name of map layer.\n            feature_collection (Dict[str, Any]): GeoJSON Feature Collection.\n\n        Returns:\n            MapLayerFeatureCollection: GeoJSON Feature Collection with D2S metadata.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}/vector_layers/geojson\"\n\n        # vector layer data\n        data = {\"layer_name\": layer_name, \"geojson\": feature_collection}\n\n        # post vector layer data\n        response_data = self.client.make_post_request(endpoint, json=data)\n\n        # return feature collection of vector layer\n        return cast(MapLayerFeatureCollection, response_data)\n\n    def get_flight(self, flight_id: str) -&gt; Optional[models.Flight]:\n        \"\"\"Request single flight by ID. Flight must be active and viewable by user.\n\n        Args:\n            flight_id (str): Flight ID.\n\n        Returns:\n            Optional[models.Flight]: Flight matching ID or None.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}/flights/{flight_id}\"\n        response_data = self.client.make_get_request(endpoint)\n        response_data = ensure_dict(response_data)\n        flight = schemas.Flight.from_dict(response_data)\n        return models.Flight(self.client, **flight.__dict__)\n\n    def get_flights(self, has_raster: Optional[bool] = False) -&gt; FlightCollection:\n        \"\"\"Return list of all active flights in project.\n\n        Args:\n            has_raster (Optional[bool], optional): Only return flights with rasters.\n\n        Returns:\n            FlightCollection: Collection of flights.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}/flights\"\n        response_data = self.client.make_get_request(\n            endpoint, params={\"has_raster\": has_raster}\n        )\n        response_data = ensure_list_of_dict(response_data)\n        flights = [\n            models.Flight(self.client, **schemas.Flight.from_dict(flight).__dict__)\n            for flight in response_data\n        ]\n        return FlightCollection(collection=flights)\n\n    def get_project_boundary(self) -&gt; Optional[ProjectBoundaryGeoJSON]:\n        \"\"\"Return project boundary in GeoJSON format.\n\n        Returns:\n            ProjectBoundaryGeoJSON: Project boundary in GeoJSON format.\n        \"\"\"\n        if hasattr(self, \"field\"):\n            return self.field\n\n        endpoint = f\"/api/v1/projects/{self.id}\"\n        response_data = self.client.make_get_request(endpoint)\n        response_data = ensure_dict(response_data)\n        project = schemas.Project.from_dict(response_data)\n        return project.field\n\n    def get_map_layers(self) -&gt; List[Dict[Any, Any]]:\n        \"\"\"Return list of GeoJSON FeatureCollections for all map layers\n        associated with this project.\n\n        Returns:\n            List[Dict[Any, Any]]: List of GeoJSON FeatureCollections.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}/vector_layers\"\n        response_data = self.client.make_get_request(\n            endpoint, params={\"format\": \"json\"}\n        )\n        response_data = ensure_list_of_dict(response_data)\n        return response_data\n\n    def update(self, **kwargs) -&gt; None:\n        \"\"\"Update project attributes.\"\"\"\n        endpoint = f\"/api/v1/projects/{self.id}\"\n        response_data = self.client.make_put_request(\n            endpoint, json=json.loads(json.dumps(kwargs, default=str))\n        )\n\n        updated_project = schemas.Project.from_dict(response_data).__dict__\n        for key, value in updated_project.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                print(f\"Warning: Attribute '{key}' not found in Project class.\")\n        return None\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.add_flight","title":"<code>add_flight(acquisition_date, altitude, side_overlap, forward_overlap, sensor, platform, name=None, pilot_id=None)</code>","text":"<p>Create new flight in a project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Name of flight.</p> <code>None</code> <code>acquisition_date</code> <code>date</code> <p>Date of flight.</p> required <code>altitude</code> <code>float</code> <p>Flight altitude.</p> required <code>side_overlap</code> <code>float</code> <p>Flight side overlap %.</p> required <code>forward_overlap</code> <code>float</code> <p>Flight forward overlap %.</p> required <code>sensor</code> <code>Literal['RGB', 'Multispectral', 'LiDAR', 'Other']</code> <p>Camera sensor.</p> required <code>platform</code> <code>Union[Literal['Phantom_4', 'M300', 'M350'], str]</code> <p>UAS platform.</p> required <code>pilot_id</code> <code>Optional[UUID]</code> <p>ID of the flight's pilot. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Flight</code> <p>models.Flight: Newly created flight.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def add_flight(\n    self,\n    acquisition_date: date,\n    altitude: float,\n    side_overlap: float,\n    forward_overlap: float,\n    sensor: Literal[\"RGB\", \"Multispectral\", \"LiDAR\", \"Other\"],\n    platform: Union[Literal[\"Phantom_4\", \"M300\", \"M350\", \"Other\"], str],\n    name: Optional[str] = None,\n    pilot_id: Optional[UUID] = None,\n) -&gt; models.Flight:\n    \"\"\"Create new flight in a project.\n\n    Args:\n        name (Optional[str]): Name of flight.\n        acquisition_date (date): Date of flight.\n        altitude (float): Flight altitude.\n        side_overlap (float): Flight side overlap %.\n        forward_overlap (float): Flight forward overlap %.\n        sensor (Literal[\"RGB\", \"Multispectral\", \"LiDAR\", \"Other\"]): Camera sensor.\n        platform (Union[Literal[\"Phantom_4\", \"M300\", \"M350\"], str]): UAS platform.\n        pilot_id (Optional[UUID]): ID of the flight's pilot. Defaults to None.\n\n    Returns:\n        models.Flight: Newly created flight.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}/flights\"\n\n    # if pilot id not provided, use current user's id\n    if not pilot_id:\n        user = self.client.make_get_request(\"/api/v1/users/current\")\n        user = ensure_dict(user)\n        pilot_id = user[\"id\"]\n\n    # form data for flight creation\n    data = {\n        \"name\": name,\n        \"acquisition_date\": acquisition_date.strftime(\"%Y-%m-%d\"),\n        \"altitude\": altitude,\n        \"side_overlap\": side_overlap,\n        \"forward_overlap\": forward_overlap,\n        \"sensor\": sensor,\n        \"platform\": platform,\n        \"pilot_id\": pilot_id,\n    }\n\n    # post form data\n    response_data = self.client.make_post_request(endpoint, json=data)\n\n    # return flight model\n    flight = models.Flight(\n        self.client, **schemas.Flight.from_dict(response_data).__dict__\n    )\n    return flight\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.add_map_layer","title":"<code>add_map_layer(layer_name, feature_collection)</code>","text":"<p>Add vector map layer to a project.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Name of map layer.</p> required <code>feature_collection</code> <code>Dict[str, Any]</code> <p>GeoJSON Feature Collection.</p> required <p>Returns:</p> Name Type Description <code>MapLayerFeatureCollection</code> <code>MapLayerFeatureCollection</code> <p>GeoJSON Feature Collection with D2S metadata.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def add_map_layer(\n    self, layer_name: str, feature_collection: Dict[str, Any]\n) -&gt; MapLayerFeatureCollection:\n    \"\"\"Add vector map layer to a project.\n\n    Args:\n        layer_name (str): Name of map layer.\n        feature_collection (Dict[str, Any]): GeoJSON Feature Collection.\n\n    Returns:\n        MapLayerFeatureCollection: GeoJSON Feature Collection with D2S metadata.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}/vector_layers/geojson\"\n\n    # vector layer data\n    data = {\"layer_name\": layer_name, \"geojson\": feature_collection}\n\n    # post vector layer data\n    response_data = self.client.make_post_request(endpoint, json=data)\n\n    # return feature collection of vector layer\n    return cast(MapLayerFeatureCollection, response_data)\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.get_flight","title":"<code>get_flight(flight_id)</code>","text":"<p>Request single flight by ID. Flight must be active and viewable by user.</p> <p>Parameters:</p> Name Type Description Default <code>flight_id</code> <code>str</code> <p>Flight ID.</p> required <p>Returns:</p> Type Description <code>Optional[Flight]</code> <p>Optional[models.Flight]: Flight matching ID or None.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def get_flight(self, flight_id: str) -&gt; Optional[models.Flight]:\n    \"\"\"Request single flight by ID. Flight must be active and viewable by user.\n\n    Args:\n        flight_id (str): Flight ID.\n\n    Returns:\n        Optional[models.Flight]: Flight matching ID or None.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}/flights/{flight_id}\"\n    response_data = self.client.make_get_request(endpoint)\n    response_data = ensure_dict(response_data)\n    flight = schemas.Flight.from_dict(response_data)\n    return models.Flight(self.client, **flight.__dict__)\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.get_flights","title":"<code>get_flights(has_raster=False)</code>","text":"<p>Return list of all active flights in project.</p> <p>Parameters:</p> Name Type Description Default <code>has_raster</code> <code>Optional[bool]</code> <p>Only return flights with rasters.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>FlightCollection</code> <code>FlightCollection</code> <p>Collection of flights.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def get_flights(self, has_raster: Optional[bool] = False) -&gt; FlightCollection:\n    \"\"\"Return list of all active flights in project.\n\n    Args:\n        has_raster (Optional[bool], optional): Only return flights with rasters.\n\n    Returns:\n        FlightCollection: Collection of flights.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}/flights\"\n    response_data = self.client.make_get_request(\n        endpoint, params={\"has_raster\": has_raster}\n    )\n    response_data = ensure_list_of_dict(response_data)\n    flights = [\n        models.Flight(self.client, **schemas.Flight.from_dict(flight).__dict__)\n        for flight in response_data\n    ]\n    return FlightCollection(collection=flights)\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.get_map_layers","title":"<code>get_map_layers()</code>","text":"<p>Return list of GeoJSON FeatureCollections for all map layers associated with this project.</p> <p>Returns:</p> Type Description <code>List[Dict[Any, Any]]</code> <p>List[Dict[Any, Any]]: List of GeoJSON FeatureCollections.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def get_map_layers(self) -&gt; List[Dict[Any, Any]]:\n    \"\"\"Return list of GeoJSON FeatureCollections for all map layers\n    associated with this project.\n\n    Returns:\n        List[Dict[Any, Any]]: List of GeoJSON FeatureCollections.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}/vector_layers\"\n    response_data = self.client.make_get_request(\n        endpoint, params={\"format\": \"json\"}\n    )\n    response_data = ensure_list_of_dict(response_data)\n    return response_data\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.get_project_boundary","title":"<code>get_project_boundary()</code>","text":"<p>Return project boundary in GeoJSON format.</p> <p>Returns:</p> Name Type Description <code>ProjectBoundaryGeoJSON</code> <code>Optional[ProjectBoundaryGeoJSON]</code> <p>Project boundary in GeoJSON format.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def get_project_boundary(self) -&gt; Optional[ProjectBoundaryGeoJSON]:\n    \"\"\"Return project boundary in GeoJSON format.\n\n    Returns:\n        ProjectBoundaryGeoJSON: Project boundary in GeoJSON format.\n    \"\"\"\n    if hasattr(self, \"field\"):\n        return self.field\n\n    endpoint = f\"/api/v1/projects/{self.id}\"\n    response_data = self.client.make_get_request(endpoint)\n    response_data = ensure_dict(response_data)\n    project = schemas.Project.from_dict(response_data)\n    return project.field\n</code></pre>"},{"location":"project/#d2spy.models.project.Project.update","title":"<code>update(**kwargs)</code>","text":"<p>Update project attributes.</p> Source code in <code>d2spy/models/project.py</code> <pre><code>def update(self, **kwargs) -&gt; None:\n    \"\"\"Update project attributes.\"\"\"\n    endpoint = f\"/api/v1/projects/{self.id}\"\n    response_data = self.client.make_put_request(\n        endpoint, json=json.loads(json.dumps(kwargs, default=str))\n    )\n\n    updated_project = schemas.Project.from_dict(response_data).__dict__\n    for key, value in updated_project.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            print(f\"Warning: Attribute '{key}' not found in Project class.\")\n    return None\n</code></pre>"},{"location":"project_collection/","title":"project_collection module","text":"<p>Collection of Data to Science projects.</p> Source code in <code>d2spy/models/project_collection.py</code> <pre><code>class ProjectCollection:\n    \"\"\"Collection of Data to Science projects.\"\"\"\n\n    def __init__(self, collection: List[Project] = []):\n        self.collection = collection\n\n    def __getitem__(self, index: int) -&gt; Project:\n        return self.collection[int(index)]\n\n    def __len__(self) -&gt; int:\n        return len(self.collection)\n\n    def __repr__(self) -&gt; str:\n        return f\"ProjectCollection({self.collection})\"\n\n    def filter_by_description(self, keyword: str) -&gt; \"ProjectCollection\":\n        \"\"\"Returns list of projects with descriptions containing text that matches\n        the keyword text.\n\n        Args:\n            keyword (str): Keyword text that will be matched with project descriptions.\n\n        Returns:\n            ProjectCollection: Collection of projects with keyword matches.\n        \"\"\"\n        filtered_collection = [\n            project\n            for project in self.collection\n            if keyword.lower() in project.description.lower()\n        ]\n        return ProjectCollection(collection=filtered_collection)\n\n    def filter_by_title(self, keyword: str) -&gt; \"ProjectCollection\":\n        \"\"\"Returns list of projects with titles containing text that matches\n        the keyword text.\n\n        Args:\n            keyword (str): Keyword text that will be matched with project titles.\n\n        Returns:\n            List[Project]: List of projects with keyword matches.\n        \"\"\"\n        filtered_collection = [\n            project\n            for project in self.collection\n            if keyword.lower() in project.title.lower()\n        ]\n        return ProjectCollection(collection=filtered_collection)\n</code></pre>"},{"location":"project_collection/#d2spy.models.project_collection.ProjectCollection.filter_by_description","title":"<code>filter_by_description(keyword)</code>","text":"<p>Returns list of projects with descriptions containing text that matches the keyword text.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>Keyword text that will be matched with project descriptions.</p> required <p>Returns:</p> Name Type Description <code>ProjectCollection</code> <code>ProjectCollection</code> <p>Collection of projects with keyword matches.</p> Source code in <code>d2spy/models/project_collection.py</code> <pre><code>def filter_by_description(self, keyword: str) -&gt; \"ProjectCollection\":\n    \"\"\"Returns list of projects with descriptions containing text that matches\n    the keyword text.\n\n    Args:\n        keyword (str): Keyword text that will be matched with project descriptions.\n\n    Returns:\n        ProjectCollection: Collection of projects with keyword matches.\n    \"\"\"\n    filtered_collection = [\n        project\n        for project in self.collection\n        if keyword.lower() in project.description.lower()\n    ]\n    return ProjectCollection(collection=filtered_collection)\n</code></pre>"},{"location":"project_collection/#d2spy.models.project_collection.ProjectCollection.filter_by_title","title":"<code>filter_by_title(keyword)</code>","text":"<p>Returns list of projects with titles containing text that matches the keyword text.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>Keyword text that will be matched with project titles.</p> required <p>Returns:</p> Type Description <code>ProjectCollection</code> <p>List[Project]: List of projects with keyword matches.</p> Source code in <code>d2spy/models/project_collection.py</code> <pre><code>def filter_by_title(self, keyword: str) -&gt; \"ProjectCollection\":\n    \"\"\"Returns list of projects with titles containing text that matches\n    the keyword text.\n\n    Args:\n        keyword (str): Keyword text that will be matched with project titles.\n\n    Returns:\n        List[Project]: List of projects with keyword matches.\n    \"\"\"\n    filtered_collection = [\n        project\n        for project in self.collection\n        if keyword.lower() in project.title.lower()\n    ]\n    return ProjectCollection(collection=filtered_collection)\n</code></pre>"},{"location":"welcome/","title":"Welcome","text":""},{"location":"workshops/","title":"Workshops","text":"<ul> <li>NAPPN 2024 Workshop - Tutorial for deploying and using Data to Science (GitBook)</li> </ul>"},{"location":"workspace/","title":"workspace module","text":"<p>Create and view projects on D2S instance.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>class Workspace:\n    \"\"\"Create and view projects on D2S instance.\"\"\"\n\n    def __init__(self, base_url: str, session: D2SpySession, api_key: str = \"\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.session = session\n\n        self.client = APIClient(self.base_url, self.session)\n\n    @classmethod\n    def connect(cls, base_url: str, email: Optional[str] = None) -&gt; \"Workspace\":\n        \"\"\"Login and create workspace. If the email argument is not provided, the\n        method will use the value of the D2S_EMAIL environment variable. If neither is\n        available, an exception will be thrown.\n\n        Args:\n            base_url (str): Base URL for D2S instance.\n            email Optional[str]: Email address used to sign in to D2S.\n\n        Returns:\n            Workspace: D2S workspace for creating and viewing data.\n        \"\"\"\n        auth = Auth(base_url)\n\n        # Check for email environment variable if not provided as argument\n        if not email:\n            email = os.environ.get(\"D2S_EMAIL\")\n            if not email:\n                raise ValueError(\n                    \"Must provide 'email' to login method as argument or set email as \"\n                    \"environment variable 'D2S_EMAIL'\"\n                )\n\n        auth.login(email=email)\n\n        # Set user api key if available\n        if hasattr(auth.session, \"d2s_data\"):\n            api_key = auth.session.d2s_data[\"API_KEY\"]\n        else:\n            api_key = \"\"\n\n        return cls(base_url, auth.session, api_key)\n\n    def logout(self) -&gt; None:\n        \"\"\"Logout of D2S platform.\"\"\"\n        # Delete access-token cookie from session and end session\n        # Clear all cookies to avoid domain-matching issues\n        # (cookies may be stored with different domains depending on host type)\n        for cookie in list(self.session.cookies):\n            if cookie.name in [\"access_token\", \"refresh_token\"]:\n                self.session.cookies.clear(cookie.domain, cookie.path, cookie.name)\n        self.session.close()\n        print(\"session ended\")\n\n    def add_project(\n        self,\n        title: str,\n        description: str,\n        location: dict,\n        start_date: Optional[date] = None,\n        end_date: Optional[date] = None,\n        planting_date: Optional[date] = None,  # Deprecated\n        harvest_date: Optional[date] = None,  # Deprecated\n    ) -&gt; models.Project:\n        \"\"\"Create new project in workspace.\n\n        Args:\n            title (str): Title for project.\n            description (str): Description of project.\n            location (dict): GeoJSON object representing location of project.\n            start_date (Optional[date]): Start date of project. Defaults to None.\n            end_date (Optional[date]): End date of project. Defaults to None.\n            planting_date (Optional[date]): Planting date. Defaults to None. Deprecated.\n            harvest_date (Optional[date]): Harvest date. Defaults to None. Deprecated.\n\n        Returns:\n            models.Project: New project instance.\n        \"\"\"\n        if planting_date:\n            warnings.warn(\n                \"'planting_date' is deprecated and will be removed in future versions.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            start_date = start_date or planting_date\n\n        start_date_serialized = (\n            start_date.isoformat() if isinstance(start_date, date) else None\n        )\n\n        if harvest_date:\n            warnings.warn(\n                \"'harvest_date' is deprecated and will be removed in future versions.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            end_date = end_date or harvest_date\n\n        end_date_serialized = (\n            end_date.isoformat() if isinstance(end_date, date) else None\n        )\n\n        endpoint = \"/api/v1/projects\"\n        data = {\n            \"title\": title,\n            \"description\": description,\n            \"location\": location,\n            \"planting_date\": start_date_serialized,\n            \"harvest_date\": end_date_serialized,\n        }\n\n        response_data = self.client.make_post_request(endpoint, json=data)\n        project = schemas.Project.from_dict(response_data)\n        return models.Project(self.client, **project.__dict__)\n\n    def get_project(self, project_id: str) -&gt; Optional[models.Project]:\n        \"\"\"Request single project by ID. Project must be active and viewable by user.\n\n        Args:\n            project_id (str): Project ID.\n\n        Returns:\n            Optional[models.Project]: Project matching ID or None.\n        \"\"\"\n        endpoint = f\"/api/v1/projects/{project_id}\"\n        response_data = self.client.make_get_request(endpoint)\n        response_data = ensure_dict(response_data)\n        project = schemas.Project.from_dict(response_data)\n        return models.Project(self.client, **project.__dict__)\n\n    def get_projects(self, has_raster: Optional[bool] = False) -&gt; ProjectCollection:\n        \"\"\"Request multiple projects. Only active projects viewable by\n        user will be returned.\n\n        Args:\n            has_raster (Optional[bool], optional): Only return projects with rasters.\n\n        Returns:\n            ProjectCollection: Collection of all projects viewable by user.\n        \"\"\"\n        endpoint = \"/api/v1/projects\"\n        response_data = self.client.make_get_request(\n            endpoint, params={\"has_raster\": has_raster}\n        )\n        response_data = ensure_list_of_dict(response_data)\n        projects = [\n            models.Project(\n                self.client, **schemas.MultiProject.from_dict(project).__dict__\n            )\n            for project in response_data\n        ]\n        return ProjectCollection(collection=projects)\n</code></pre>"},{"location":"workspace/#d2spy.workspace.Workspace.add_project","title":"<code>add_project(title, description, location, start_date=None, end_date=None, planting_date=None, harvest_date=None)</code>","text":"<p>Create new project in workspace.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title for project.</p> required <code>description</code> <code>str</code> <p>Description of project.</p> required <code>location</code> <code>dict</code> <p>GeoJSON object representing location of project.</p> required <code>start_date</code> <code>Optional[date]</code> <p>Start date of project. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>Optional[date]</code> <p>End date of project. Defaults to None.</p> <code>None</code> <code>planting_date</code> <code>Optional[date]</code> <p>Planting date. Defaults to None. Deprecated.</p> <code>None</code> <code>harvest_date</code> <code>Optional[date]</code> <p>Harvest date. Defaults to None. Deprecated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>models.Project: New project instance.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>def add_project(\n    self,\n    title: str,\n    description: str,\n    location: dict,\n    start_date: Optional[date] = None,\n    end_date: Optional[date] = None,\n    planting_date: Optional[date] = None,  # Deprecated\n    harvest_date: Optional[date] = None,  # Deprecated\n) -&gt; models.Project:\n    \"\"\"Create new project in workspace.\n\n    Args:\n        title (str): Title for project.\n        description (str): Description of project.\n        location (dict): GeoJSON object representing location of project.\n        start_date (Optional[date]): Start date of project. Defaults to None.\n        end_date (Optional[date]): End date of project. Defaults to None.\n        planting_date (Optional[date]): Planting date. Defaults to None. Deprecated.\n        harvest_date (Optional[date]): Harvest date. Defaults to None. Deprecated.\n\n    Returns:\n        models.Project: New project instance.\n    \"\"\"\n    if planting_date:\n        warnings.warn(\n            \"'planting_date' is deprecated and will be removed in future versions.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        start_date = start_date or planting_date\n\n    start_date_serialized = (\n        start_date.isoformat() if isinstance(start_date, date) else None\n    )\n\n    if harvest_date:\n        warnings.warn(\n            \"'harvest_date' is deprecated and will be removed in future versions.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        end_date = end_date or harvest_date\n\n    end_date_serialized = (\n        end_date.isoformat() if isinstance(end_date, date) else None\n    )\n\n    endpoint = \"/api/v1/projects\"\n    data = {\n        \"title\": title,\n        \"description\": description,\n        \"location\": location,\n        \"planting_date\": start_date_serialized,\n        \"harvest_date\": end_date_serialized,\n    }\n\n    response_data = self.client.make_post_request(endpoint, json=data)\n    project = schemas.Project.from_dict(response_data)\n    return models.Project(self.client, **project.__dict__)\n</code></pre>"},{"location":"workspace/#d2spy.workspace.Workspace.connect","title":"<code>connect(base_url, email=None)</code>  <code>classmethod</code>","text":"<p>Login and create workspace. If the email argument is not provided, the method will use the value of the D2S_EMAIL environment variable. If neither is available, an exception will be thrown.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for D2S instance.</p> required <code>email Optional[str]</code> <p>Email address used to sign in to D2S.</p> required <p>Returns:</p> Name Type Description <code>Workspace</code> <code>Workspace</code> <p>D2S workspace for creating and viewing data.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>@classmethod\ndef connect(cls, base_url: str, email: Optional[str] = None) -&gt; \"Workspace\":\n    \"\"\"Login and create workspace. If the email argument is not provided, the\n    method will use the value of the D2S_EMAIL environment variable. If neither is\n    available, an exception will be thrown.\n\n    Args:\n        base_url (str): Base URL for D2S instance.\n        email Optional[str]: Email address used to sign in to D2S.\n\n    Returns:\n        Workspace: D2S workspace for creating and viewing data.\n    \"\"\"\n    auth = Auth(base_url)\n\n    # Check for email environment variable if not provided as argument\n    if not email:\n        email = os.environ.get(\"D2S_EMAIL\")\n        if not email:\n            raise ValueError(\n                \"Must provide 'email' to login method as argument or set email as \"\n                \"environment variable 'D2S_EMAIL'\"\n            )\n\n    auth.login(email=email)\n\n    # Set user api key if available\n    if hasattr(auth.session, \"d2s_data\"):\n        api_key = auth.session.d2s_data[\"API_KEY\"]\n    else:\n        api_key = \"\"\n\n    return cls(base_url, auth.session, api_key)\n</code></pre>"},{"location":"workspace/#d2spy.workspace.Workspace.get_project","title":"<code>get_project(project_id)</code>","text":"<p>Request single project by ID. Project must be active and viewable by user.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID.</p> required <p>Returns:</p> Type Description <code>Optional[Project]</code> <p>Optional[models.Project]: Project matching ID or None.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>def get_project(self, project_id: str) -&gt; Optional[models.Project]:\n    \"\"\"Request single project by ID. Project must be active and viewable by user.\n\n    Args:\n        project_id (str): Project ID.\n\n    Returns:\n        Optional[models.Project]: Project matching ID or None.\n    \"\"\"\n    endpoint = f\"/api/v1/projects/{project_id}\"\n    response_data = self.client.make_get_request(endpoint)\n    response_data = ensure_dict(response_data)\n    project = schemas.Project.from_dict(response_data)\n    return models.Project(self.client, **project.__dict__)\n</code></pre>"},{"location":"workspace/#d2spy.workspace.Workspace.get_projects","title":"<code>get_projects(has_raster=False)</code>","text":"<p>Request multiple projects. Only active projects viewable by user will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>has_raster</code> <code>Optional[bool]</code> <p>Only return projects with rasters.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ProjectCollection</code> <code>ProjectCollection</code> <p>Collection of all projects viewable by user.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>def get_projects(self, has_raster: Optional[bool] = False) -&gt; ProjectCollection:\n    \"\"\"Request multiple projects. Only active projects viewable by\n    user will be returned.\n\n    Args:\n        has_raster (Optional[bool], optional): Only return projects with rasters.\n\n    Returns:\n        ProjectCollection: Collection of all projects viewable by user.\n    \"\"\"\n    endpoint = \"/api/v1/projects\"\n    response_data = self.client.make_get_request(\n        endpoint, params={\"has_raster\": has_raster}\n    )\n    response_data = ensure_list_of_dict(response_data)\n    projects = [\n        models.Project(\n            self.client, **schemas.MultiProject.from_dict(project).__dict__\n        )\n        for project in response_data\n    ]\n    return ProjectCollection(collection=projects)\n</code></pre>"},{"location":"workspace/#d2spy.workspace.Workspace.logout","title":"<code>logout()</code>","text":"<p>Logout of D2S platform.</p> Source code in <code>d2spy/workspace.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Logout of D2S platform.\"\"\"\n    # Delete access-token cookie from session and end session\n    # Clear all cookies to avoid domain-matching issues\n    # (cookies may be stored with different domains depending on host type)\n    for cookie in list(self.session.cookies):\n        if cookie.name in [\"access_token\", \"refresh_token\"]:\n            self.session.cookies.clear(cookie.domain, cookie.path, cookie.name)\n    self.session.close()\n    print(\"session ended\")\n</code></pre>"},{"location":"guides/notebooks/01_creating_workspace_data/","title":"Creating new projects, flights, and data products","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy In\u00a0[\u00a0]: Copied! <pre>from datetime import date\n\nfrom d2spy.workspace import Workspace\n</pre> from datetime import date  from d2spy.workspace import Workspace <p>All of your D2S data can be accessed through a D2S \"workspace.\" The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go. Behind the scenes, the <code>Auth</code> module will be used to handle authenticating with D2S and requesting an authorization token. You will need to provide <code>connect</code> with the URL to your D2S instance and enter your password when prompted. Once connected to your workspace, you will be able to start creating projects within it.</p> In\u00a0[\u00a0]: Copied! <pre># Example of connecting to a workspace for a local D2S instance\nworkspace = Workspace.connect(\"http://localhost:8000\", \"yourD2Semail@example.com\")\n</pre> # Example of connecting to a workspace for a local D2S instance workspace = Workspace.connect(\"http://localhost:8000\", \"yourD2Semail@example.com\") <p>To create a new project in our workspace, we can use the Workspace module's <code>add_project</code> method as follows:</p> In\u00a0[\u00a0]: Copied! <pre># At minimum, must provide title, description, and location (dict in GeoJSON Feature format)\nproject = workspace.add_project(\n    title=\"Project title\",\n    description=\"Project for testing d2spy package.\",\n    location={\n        \"type\": \"Feature\",\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                  [-86.944981783977838, 41.444435853085622],\n                  [-86.943319754949272, 41.444435046238446],\n                  [-86.94332056379109, 41.443505552529658],\n                  [-86.944982569102066, 41.443506359350643],\n                  [-86.944981783977838, 41.444435853085622]\n                ]\n            ]\n        },\n        \"properties\": {\n            \"prop0\": \"value0\"\n        }\n    },\n    start_date=date(2024, 4, 15), # Optional\n    end_date=date(2024, 9, 15) # Optional\n)\nprint(project)\n</pre> # At minimum, must provide title, description, and location (dict in GeoJSON Feature format) project = workspace.add_project(     title=\"Project title\",     description=\"Project for testing d2spy package.\",     location={         \"type\": \"Feature\",         \"geometry\": {             \"type\": \"Polygon\",             \"coordinates\": [                 [                   [-86.944981783977838, 41.444435853085622],                   [-86.943319754949272, 41.444435046238446],                   [-86.94332056379109, 41.443505552529658],                   [-86.944982569102066, 41.443506359350643],                   [-86.944981783977838, 41.444435853085622]                 ]             ]         },         \"properties\": {             \"prop0\": \"value0\"         }     },     start_date=date(2024, 4, 15), # Optional     end_date=date(2024, 9, 15) # Optional ) print(project) <p>The Workspace module's <code>add_project</code> returns a <code>Project</code> instance we can use to create new flights in the project, retrieve existing flights, and update the initially provided project details.</p> <p>For example, we can use the Project <code>update</code> method to change the project title.</p> In\u00a0[\u00a0]: Copied! <pre>print(f\"Original title: {project.title}\")\nproject.update(title=\"My First D2S Project\")\nprint(f\"Updated title: {project.title}\")\n</pre> print(f\"Original title: {project.title}\") project.update(title=\"My First D2S Project\") print(f\"Updated title: {project.title}\") <p>Since this is a new project, we do not have any available flights yet. We can add a flight using the Project module's <code>add_flight</code> method.</p> <p>Important</p> <p>The <code>sensor</code> and <code>platform</code> attributes have some limits on what values will be accepted. <code>Sensor</code> will only accept the values: \"RGB\", \"Multispectral\", \"LiDAR\", and \"Other\". <code>Platform</code> expects the values \"Phantom_4\", \"M300\", or \"M350\". It can be provided with an alternative value if none of these options are suitable.</p> <p>Refer to the documentation for more details.</p> In\u00a0[\u00a0]: Copied! <pre># Example flight form\nflight = project.add_flight(\n    acquisition_date=date(2023, 6, 3),  # string in YYYY-MM-DD format also acceptable\n    altitude=40,\n    side_overlap=85,\n    forward_overlap=85,\n    sensor=\"RGB\",\n    platform=\"M350\"\n)\nprint(flight)\n</pre> # Example flight form flight = project.add_flight(     acquisition_date=date(2023, 6, 3),  # string in YYYY-MM-DD format also acceptable     altitude=40,     side_overlap=85,     forward_overlap=85,     sensor=\"RGB\",     platform=\"M350\" ) print(flight) <p>Now that a flight has been created, you can start uploading data products to the flight. Note, the data product will not be immediately available after the upload completes. When D2S receives a new GeoTIFF, it will check if it is in a cloud-optimized format, and if not, perform this conversion. This process may take several minutes to complete.</p> <p>The Flight module's <code>add_data_product</code> method will be used to upload a GeoTIFF located on the local machine. You will need to have a GeoTIFF and know its filepath for this next cell.</p> <p>Important</p> <p>The <code>data_type</code> has some limits on what values will be accepted. <code>data_type</code> expects the values \"dsm\", \"point_cloud\", or \"ortho\". It can be provided with an alternative value if none of these options are suitable.</p> <p>Refer to the documentation for more details.</p> In\u00a0[\u00a0]: Copied! <pre>my_geotiff = \"/full/path/to/my/data_product.tif\"\nflight.add_data_product(\n    filepath=my_geotiff,\n    data_type=\"dsm\"\n)\n</pre> my_geotiff = \"/full/path/to/my/data_product.tif\" flight.add_data_product(     filepath=my_geotiff,     data_type=\"dsm\" ) <p>When D2S has finished processing the upload, the Flight module's <code>get_data_products</code> method can be used to find the uploaded data product and its static URL.</p> In\u00a0[\u00a0]: Copied! <pre>data_products = flight.get_data_products()\ntry:\n    print(data_products[0].url)\nexcept IndexError:\n    print(\"Data product still processing or an unexpected error has occurred\")\n</pre> data_products = flight.get_data_products() try:     print(data_products[0].url) except IndexError:     print(\"Data product still processing or an unexpected error has occurred\") <p>Zipped raw data can also be uploaded to a flight using d2spy. In the next cell, the Flight module's <code>add_raw_data</code> method will be used to upload a zipped folder containing raw images located on the local machine.</p> In\u00a0[\u00a0]: Copied! <pre>my_rawdata = \"/full/path/to/my/raw_data.zip\"\nflight.add_raw_data(filepath=my_rawdata)\n</pre> my_rawdata = \"/full/path/to/my/raw_data.zip\" flight.add_raw_data(filepath=my_rawdata) <p>When D2S has finished processing the upload, the Flight module's <code>get_raw_data</code> method can be used to find the uploaded raw data zip and its static URL.</p> In\u00a0[\u00a0]: Copied! <pre>raw_data = flight.get_raw_data()\ntry:\n    print(raw_data[0].url)\nexcept IndexError:\n    print(\"Raw data is still processing or an unexpected error has occurred\")\n</pre> raw_data = flight.get_raw_data() try:     print(raw_data[0].url) except IndexError:     print(\"Raw data is still processing or an unexpected error has occurred\") <p>Vector data in the GeoJSON Feature Collection format can be added to a project using a Project's <code>add_map_layer</code> method. The method's <code>layer_name</code> parameter can be used to name the map layer.</p> In\u00a0[\u00a0]: Copied! <pre>layer_name = \"My Map Layer\"\nfeature_collection = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"row\": 1, \"col\": 1},\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-86.944517485972483, 41.444077836565455, 0.0],\n                        [-86.94450551488066, 41.444077830791521, 0.0],\n                        [-86.94450552255509, 41.444068823253602, 0.0],\n                        [-86.94451749364525, 41.444068829027536, 0.0],\n                        [-86.944517485972483, 41.444077836565455, 0.0],\n                    ]\n                ],\n            },\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"row\": 1, \"col\": 2},\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-86.944493543788852, 41.444077825016343, 0.0],\n                        [-86.944481572697043, 41.444077819239929, 0.0],\n                        [-86.94448158037477, 41.44406881170201, 0.0],\n                        [-86.94449355146493, 41.444068817478424, 0.0],\n                        [-86.944493543788852, 41.444077825016343, 0.0],\n                    ]\n                ],\n            },\n        },\n    ],\n}\n# Add the map layer to the project\nmap_layer_feature_collection = project.add_map_layer(feature_collection=feature_collection, layer_name=layer_name)\n\n# The returned feature collection will contain additional D2S metadata such as the URL for a preview image of the map layer\nprint(map_layer_feature_collection[\"metadata\"][\"preview_url\"])\n</pre> layer_name = \"My Map Layer\" feature_collection = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {\"row\": 1, \"col\": 1},             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-86.944517485972483, 41.444077836565455, 0.0],                         [-86.94450551488066, 41.444077830791521, 0.0],                         [-86.94450552255509, 41.444068823253602, 0.0],                         [-86.94451749364525, 41.444068829027536, 0.0],                         [-86.944517485972483, 41.444077836565455, 0.0],                     ]                 ],             },         },         {             \"type\": \"Feature\",             \"properties\": {\"row\": 1, \"col\": 2},             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-86.944493543788852, 41.444077825016343, 0.0],                         [-86.944481572697043, 41.444077819239929, 0.0],                         [-86.94448158037477, 41.44406881170201, 0.0],                         [-86.94449355146493, 41.444068817478424, 0.0],                         [-86.944493543788852, 41.444077825016343, 0.0],                     ]                 ],             },         },     ], } # Add the map layer to the project map_layer_feature_collection = project.add_map_layer(feature_collection=feature_collection, layer_name=layer_name)  # The returned feature collection will contain additional D2S metadata such as the URL for a preview image of the map layer print(map_layer_feature_collection[\"metadata\"][\"preview_url\"]) <p>These are all the methods you need to know for viewing what data your account can access on a D2S instance. Once finished exploring your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre># Removes access token from future requests\nworkspace.logout()\n</pre> # Removes access token from future requests workspace.logout()"},{"location":"guides/notebooks/01_creating_workspace_data/#creating-new-projects-flights-and-data-products","title":"Creating new projects, flights, and data products\u00b6","text":"<p>This guide will walk you through the steps for creating new data on a Data to Science (D2S) instance.</p> <p>To get started, you will need to import the <code>Workspace</code> modules.</p>"},{"location":"guides/notebooks/01_creating_workspace_data/#creating-a-new-project","title":"Creating a new project\u00b6","text":""},{"location":"guides/notebooks/01_creating_workspace_data/#optional-information","title":"Optional information\u00b6","text":"<p>If you don't have the coordinates for the project location but have a directory of raw images or a zip file from a flight, you can use our utility function to extract the bounding box coordinates from the images' EXIF data. Here's an example:</p> <pre>from d2spy.extras.utils import get_bounding_box_from_exif_data\n\ncoordinates = get_bounding_box_from_exif_data(\"/path/to/image_dir\")\n# coordinates = get_bounding_box_from_exif_data(\"/path/to/images.zip\")  # Zip files work too\n</pre> <p>You can use these coordinates as the project location when creating your project.</p>"},{"location":"guides/notebooks/01_creating_workspace_data/#adding-a-flight-to-a-project","title":"Adding a flight to a project\u00b6","text":""},{"location":"guides/notebooks/01_creating_workspace_data/#uploading-a-data-product-to-a-flight","title":"Uploading a data product to a flight\u00b6","text":""},{"location":"guides/notebooks/01_creating_workspace_data/#uploading-raw-data-to-a-flight","title":"Uploading raw data to a flight\u00b6","text":""},{"location":"guides/notebooks/01_creating_workspace_data/#add-vector-map-layers-to-a-project","title":"Add vector map layers to a project\u00b6","text":""},{"location":"guides/notebooks/02_accessing_your_workspace/","title":"Accessing your workspace projects, flights, and data products","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy In\u00a0[\u00a0]: Copied! <pre>from datetime import date\n\nfrom d2spy.workspace import Workspace\n</pre> from datetime import date  from d2spy.workspace import Workspace <p>All of your D2S data can be accessed through a D2S \"workspace.\" The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go. Behind the scenes, the <code>Auth</code> module will be used to handle authenticating with D2S and requesting an authorization token. You will need to provide <code>connect</code> with the URL to your D2S instance and enter your password when prompted.</p> In\u00a0[\u00a0]: Copied! <pre># Example of connecting to a workspace for a local D2S instance\nworkspace = Workspace.connect(\"https://ps2.d2s.org\")\n</pre> # Example of connecting to a workspace for a local D2S instance workspace = Workspace.connect(\"https://ps2.d2s.org\") <p>The Workspace <code>get_projects</code> method will retrieve a collection of the projects your account can currently access on the D2S instance.</p> In\u00a0[\u00a0]: Copied! <pre># Get list of all your projects\nprojects = workspace.get_projects()\n# Print title of first project (if one exists)\nif len(projects) &gt; 0:\n    print(projects[0])\nelse:\n    print(\"Please create a project before proceeding with this guide.\")\n</pre> # Get list of all your projects projects = workspace.get_projects() # Print title of first project (if one exists) if len(projects) &gt; 0:     print(projects[0]) else:     print(\"Please create a project before proceeding with this guide.\") <p>The <code>projects</code> variable is a <code>ProjectCollection</code>. The collection can be filtered by either the project descriptions or titles using the methods <code>filter_by_title</code> or <code>filter_by_name</code>.</p> In\u00a0[\u00a0]: Copied! <pre># Example of creating new collection of only projects with the keyword \"Test\" in the title\nfiltered_projects = projects.filter_by_title(\"Test\")\nprint(filtered_projects)\n</pre> # Example of creating new collection of only projects with the keyword \"Test\" in the title filtered_projects = projects.filter_by_title(\"Test\") print(filtered_projects) <p>The Project <code>get_project_boundary</code> method will retrieve a GeoJSON object of the project boundary.</p> In\u00a0[\u00a0]: Copied! <pre># Get project boundary as Python dictionary in GeoJSON structure\nproject_boundary = projects[0].get_project_boundary()\nprint(project_boundary)\n</pre> # Get project boundary as Python dictionary in GeoJSON structure project_boundary = projects[0].get_project_boundary() print(project_boundary) <p>The Project <code>get_flights</code> method will retrieve a list of the flights associated with a project.</p> In\u00a0[\u00a0]: Copied! <pre># Get list of all flights for a project\nflights = projects[0].get_flights()\n# Print first flight object (if one exists)\nif len(flights) &gt; 0:\n    print(flights[0])\n</pre> # Get list of all flights for a project flights = projects[0].get_flights() # Print first flight object (if one exists) if len(flights) &gt; 0:     print(flights[0]) <p>The <code>flights</code> variable is a <code>FlightCollection</code>. The collection can be filtered by the acquisition date using the method <code>filter_by_date</code>. This method will return all flights with an acquisition date bewteen the provided start and end dates.</p> In\u00a0[\u00a0]: Copied! <pre># Example of creating new collection of only flights from May 2024 - June 2024\nfiltered_flights = flights.filter_by_date(start_date=date(2024, 5, 1), end_date=date(2024, 6, 30))\nprint(filtered_flights)\n</pre> # Example of creating new collection of only flights from May 2024 - June 2024 filtered_flights = flights.filter_by_date(start_date=date(2024, 5, 1), end_date=date(2024, 6, 30)) print(filtered_flights) <p>A <code>FlightCollection</code> can also be filtered by sensor using the method <code>filter_by_sensor</code>. This method will return all flights with a sensor that matches the provided search term.</p> In\u00a0[\u00a0]: Copied! <pre>filtered_flights = filtered_flights.filter_by_sensor(\"rgb\")\nprint(filtered_flights)\n</pre> filtered_flights = filtered_flights.filter_by_sensor(\"rgb\") print(filtered_flights) <p>The Flight <code>get_data_products</code> method will retrieve a list of the data products associated with a flight.</p> In\u00a0[\u00a0]: Copied! <pre># Get list of data products from a flight\ndata_products = flights[0].get_data_products()\n# Print the url for the first data product (if one exists)\nprint(data_products[0].url)\n</pre> # Get list of data products from a flight data_products = flights[0].get_data_products() # Print the url for the first data product (if one exists) print(data_products[0].url) <p>The <code>data_products</code> variable is a <code>DataProductCollection</code>. The collection can be filtered by the data type using the method <code>filter_by_data_type</code>. This method will return all data products that match the requested data type.</p> In\u00a0[\u00a0]: Copied! <pre># Example of creating new collection of data products with the \"ortho\" data type\nfiltered_data_products = data_products.filter_by_data_type(\"ortho\")\nprint(filtered_data_products)\n</pre> # Example of creating new collection of data products with the \"ortho\" data type filtered_data_products = data_products.filter_by_data_type(\"ortho\") print(filtered_data_products) <p>We can access the band info for a <code>DataProduct</code> using the <code>get_band_info</code> method. The <code>update_band_info</code> method can be used to assign a new <code>description</code> to one or more bands. Only the band <code>description</code> values can be changed. The band <code>name</code> values must remain the same.</p> <p>Example band info returned from <code>get_band_info</code> for a 4-band orthomosaic:</p> <pre>[\n    {'name': 'b1', 'description': 'Red'},\n    {'name': 'b2', 'description': 'Green'},\n    {'name': 'b3', 'description': 'Blue'},\n    {'name': 'b4', 'description': 'Alpha'}\n]\n</pre> In\u00a0[\u00a0]: Copied! <pre># Print band names and descriptions for a data product\nband_info = filtered_data_products[0].get_band_info()\nprint(band_info)\n\n# Update \"b1\" and \"b3\" band descriptions\nband_info[0][\"description\"] = \"Blue\"\nband_info[2][\"description\"] = \"Red\"\nfiltered_data_products[0].update_band_info(band_info)\n</pre> # Print band names and descriptions for a data product band_info = filtered_data_products[0].get_band_info() print(band_info)  # Update \"b1\" and \"b3\" band descriptions band_info[0][\"description\"] = \"Blue\" band_info[2][\"description\"] = \"Red\" filtered_data_products[0].update_band_info(band_info) <p>These are all the methods you need to know for viewing what data your account can access on a D2S instance. Once finished exploring your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre># Removes access token from future requests\nworkspace.logout()\n</pre> # Removes access token from future requests workspace.logout()"},{"location":"guides/notebooks/02_accessing_your_workspace/#accessing-your-workspace-projects-flights-and-data-products","title":"Accessing your workspace projects, flights, and data products\u00b6","text":"<p>This guide will walk you through the steps for requesting data from a Data to Science (D2S) instance.</p> <p>To get started, you will need to import the <code>Workspace</code> module.</p>"},{"location":"guides/notebooks/03_adding_multiple_data_products/","title":"Adding multiple data products to an existing flight","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy In\u00a0[\u00a0]: Copied! <pre>from d2spy.workspace import Workspace\n</pre> from d2spy.workspace import Workspace <p>All of your D2S data can be accessed through a D2S \"workspace.\" The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go. Behind the scenes, the <code>Auth</code> module will be used to handle authenticating with D2S and requesting an authorization token. You will need to provide <code>connect</code> with the URL to your D2S instance and enter your password when prompted.</p> In\u00a0[\u00a0]: Copied! <pre># Example of connecting to a workspace for a local D2S instance\nworkspace = Workspace.connect(\"http://localhost:8000\", \"yourD2Semail@example.com\")\n</pre> # Example of connecting to a workspace for a local D2S instance workspace = Workspace.connect(\"http://localhost:8000\", \"yourD2Semail@example.com\") <p>The Workspace <code>get_project</code> method will use a project ID to retrieve a specific project on your D2S instance. Once we have the project, we can use the project's <code>get_flight</code> method to find a specific flight by its ID.</p> <p>You can find the project ID in the URL of your project page on your D2S instance, or by using the <code>get_projects</code> method to retrieve all projects and identifying the project ID from the returned list. Similarly, the flight ID can be found in the URL of your flight's data product page on your D2S instance, or by using the <code>get_flights</code> method. See the second guide, Accessing your workspace projects, flights, and data products, for detailed examples using these methods.</p> In\u00a0[\u00a0]: Copied! <pre># Find specific project in our workspace\nproject = workspace.get_project(\"a538eb21-cb9a-488b-989c-d82098cd843d\")\nif not project:\n    print(\"Unable to find project\")\n\n# Find specific flight in our project\nflight = project.get_flight(\"526e316c-3373-435c-a0f0-3781ced28508\")\nif not flight:\n    print(\"Unable to find flight\")\n</pre> # Find specific project in our workspace project = workspace.get_project(\"a538eb21-cb9a-488b-989c-d82098cd843d\") if not project:     print(\"Unable to find project\")  # Find specific flight in our project flight = project.get_flight(\"526e316c-3373-435c-a0f0-3781ced28508\") if not flight:     print(\"Unable to find flight\") <p>The Flight module's <code>add_data_product</code> method will be used to upload multiple data products located on the local machine.</p> <p>Important</p> <p>The <code>data_type</code> has some limits on what values will be accepted. <code>data_type</code> expects the values \"dsm\", \"point_cloud\", or \"ortho\". It can be provided with an alternative value if none of these options are suitable.</p> <p>Refer to the documentation for more details.</p> In\u00a0[\u00a0]: Copied! <pre># List of local data products that will be uploaded\ndata_products_to_upload = [\n    {\"filepath\": \"/full/path/to/my/ortho_data_product.tif\", \"data_type\": \"ortho\"},\n    {\"filepath\": \"/full/path/to/my/dsm_data_product.tif\", \"data_type\": \"dsm\"},\n    {\"filepath\": \"/full/path/to/my/point_cloud_data_product.tif\", \"data_type\": \"point_cloud\"}\n]\n\n# Upload each data product to D2S instance\nfor data_product in data_products_to_upload:\n    flight.add_data_product(\n        filepath=data_product[\"filepath\"],\n        data_type=data_product[\"data_type\"]\n    )\n</pre> # List of local data products that will be uploaded data_products_to_upload = [     {\"filepath\": \"/full/path/to/my/ortho_data_product.tif\", \"data_type\": \"ortho\"},     {\"filepath\": \"/full/path/to/my/dsm_data_product.tif\", \"data_type\": \"dsm\"},     {\"filepath\": \"/full/path/to/my/point_cloud_data_product.tif\", \"data_type\": \"point_cloud\"} ]  # Upload each data product to D2S instance for data_product in data_products_to_upload:     flight.add_data_product(         filepath=data_product[\"filepath\"],         data_type=data_product[\"data_type\"]     ) <p>When D2S has finished processing the upload the Flight module's <code>get_data_products</code> method can be used to find the uploaded data products' static URLs.</p> In\u00a0[\u00a0]: Copied! <pre>data_products = flight.get_data_products()\n\n# If an uploaded data product is missing from the output it may need more time to process on D2S\nfor data_product in data_products:\n    print(data_product.url)\n</pre> data_products = flight.get_data_products()  # If an uploaded data product is missing from the output it may need more time to process on D2S for data_product in data_products:     print(data_product.url) <p>These are all the methods you need to know for viewing what data your account can access on a D2S instance. Once finished exploring your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre># Removes access token from future requests\nworkspace.logout()\n</pre> # Removes access token from future requests workspace.logout()"},{"location":"guides/notebooks/03_adding_multiple_data_products/#adding-multiple-data-products-to-an-existing-flight","title":"Adding multiple data products to an existing flight\u00b6","text":"<p>This guide will walk you through the steps for adding multiple data products, of different data types, to an existing flight.</p> <p>To get started, you will need to import the <code>Workspace</code> modules.</p>"},{"location":"guides/notebooks/04_visualizing_data_products_with_leafmap/","title":"Visualizing data products with leafmap","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy\n# !pip install leafmap\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\n\nimport leafmap\n\nfrom d2spy.workspace import Workspace\n</pre> import os  import leafmap  from d2spy.workspace import Workspace <p>You must connect to your D2S workspace before you can request any data. The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go.</p> <p>Note: This tutorial uses a D2S instance hosted at https://ps2.d2s.org. You will need to have an account and access to data on this instance to use it. Change the URL if you are self-hosting an instance or using an instance hosted elsewhere.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to D2S workspace\nworkspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\")\n</pre> # Connect to D2S workspace workspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\") <p>An API key will need to be used to view private D2S hosted data products. Data products toggled to public on D2S do not require an API key.</p> <p>Your API key will be accessible from the workspace <code>api_key</code> property.</p> <p>Important</p> <p>You will not have an active API key by default. You must request one from the D2S profile page. As an example, here is the profile page URL for a local development server: http://localhost:8000/auth/profile</p> In\u00a0[\u00a0]: Copied! <pre># Check for API key\napi_key = workspace.api_key\nif not api_key:\n    print(\"No API key. Please request one from the D2S profile page and re-run this cell.\")\n</pre> # Check for API key api_key = workspace.api_key if not api_key:     print(\"No API key. Please request one from the D2S profile page and re-run this cell.\") <p>Leafmap uses TiTiler, a dynamic tile server, for streaming map tiles to its interactive map. On this next line, we will set up an environment variable that points to the demo TiTiler service.</p> In\u00a0[\u00a0]: Copied! <pre>os.environ[\"TITILER_ENDPOINT\"] = \"https://tt.d2s.org\"\n</pre> os.environ[\"TITILER_ENDPOINT\"] = \"https://tt.d2s.org\" <p>Next, we will create a default leafmap Map and provide the URL for our D2S hosted data product.</p> <p>D2S automatically converts uploaded GeoTIFF data products to the Cloud Optimized GeoTIFF (COG) format. This format is what makes it possible to stream the data product from D2S to TiTiler which in turn serves the tiles rendered on our map.</p> In\u00a0[\u00a0]: Copied! <pre># Interactive leafmap Map\nm = leafmap.Map()\n\n# URL for a D2S hosted GeoTIFF data product\northo_url = \"https://ps2.d2s.org/static/projects/afc5005d-4977-4bdd-a53a-96a3f051d312/flights/32607eae-0cd9-4c06-b4d1-a4837d237ce1/data_products/0e4c3bc2-00da-41b3-bf79-d1d1f83e4194/bb62658b-a250-46e2-8e93-081828880634.tif\"\n\n# Add a publicly available data product to the map\nm.add_cog_layer(ortho_url, name=\"Orthomosaic\")\n\n# If you want to display a private data product, comment out the previously line and uncomment the below m.add_cog_layer line\n# Add a private data product to the map\n# m.add_cog_layer(f\"{ortho_url}?API_KEY={api_key}\", name=\"DSM\", colormap_name=\"rainbow\")\n\n# Display the map\nm\n</pre> # Interactive leafmap Map m = leafmap.Map()  # URL for a D2S hosted GeoTIFF data product ortho_url = \"https://ps2.d2s.org/static/projects/afc5005d-4977-4bdd-a53a-96a3f051d312/flights/32607eae-0cd9-4c06-b4d1-a4837d237ce1/data_products/0e4c3bc2-00da-41b3-bf79-d1d1f83e4194/bb62658b-a250-46e2-8e93-081828880634.tif\"  # Add a publicly available data product to the map m.add_cog_layer(ortho_url, name=\"Orthomosaic\")  # If you want to display a private data product, comment out the previously line and uncomment the below m.add_cog_layer line # Add a private data product to the map # m.add_cog_layer(f\"{ortho_url}?API_KEY={api_key}\", name=\"DSM\", colormap_name=\"rainbow\")  # Display the map m <p>Once finished viewing your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre># Removes access token from future requests\nworkspace.logout()\n</pre> # Removes access token from future requests workspace.logout()"},{"location":"guides/notebooks/04_visualizing_data_products_with_leafmap/#visualizing-data-products-with-leafmap","title":"Visualizing data products with leafmap\u00b6","text":"<p>This guide will walk you through the steps for visualizing a D2S hosted data product with leafmap.</p> <p>To get started, you will need to have the URL for one of your D2S data products and the open-source library leafmap added to your Python environment.</p>"},{"location":"guides/notebooks/05_visualizing_projects_with_leafmap/","title":"Visualizing project locations with leafmap","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy\n# !pip install leafmap\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport pandas as pd\n\nfrom d2spy.workspace import Workspace\n</pre> import leafmap import pandas as pd  from d2spy.workspace import Workspace <p>You must connect to your D2S workspace before you can request any data. The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go.</p> <p>Note: This tutorial uses a D2S instance hosted at https://ps2.d2s.org. You will need to have an account and access to data on this instance to use it. Change the URL if you are self-hosting an instance or using an instance hosted elsewhere.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to D2S workspace\nworkspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\")\n</pre> # Connect to D2S workspace workspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\") <p>The Workspace <code>get_projects</code> method will retrieve a list of the projects your account can currently access on the D2S instance.</p> In\u00a0[\u00a0]: Copied! <pre># Get list of all your projects\nprojects = workspace.get_projects()\nprint(projects[0])\n</pre> # Get list of all your projects projects = workspace.get_projects() print(projects[0]) <p>The <code>projects</code> variable now contains a list of <code>Project</code> objects. You can access attributes such as <code>title</code>, <code>description</code>, <code>start_date</code>, <code>end_date</code>, and <code>field</code> from a <code>Project</code> object. The <code>field</code> attribute contains a GeoJSON representation of the field boundary provided during the project's creation.</p> <p>Next, leafmap will be used to plot markers on a map at the location of each of your projects. It requires the location information to be stored in either a CSV file or pandas DataFrame. The next two cells will create a pandas DataFrame containing your project titles and center coordinates.</p> In\u00a0[\u00a0]: Copied! <pre># Now make a dictionary that can be used to create a DataFrame\ndata = []\n# Store the project title and the project center coordinates for each project in the workspace\nfor project in projects:\n    data.append([project.title, project.centroid['x'], project.centroid['y']])\n</pre> # Now make a dictionary that can be used to create a DataFrame data = [] # Store the project title and the project center coordinates for each project in the workspace for project in projects:     data.append([project.title, project.centroid['x'], project.centroid['y']]) In\u00a0[\u00a0]: Copied! <pre># Now create a Pandas dataFrame\ndf = pd.DataFrame(data, columns=['title', 'x', 'y'])\n</pre> # Now create a Pandas dataFrame df = pd.DataFrame(data, columns=['title', 'x', 'y']) <p>With the project titles and center coordinates now stored in a DataFrame, you can plot them using leafmap.</p> <p>Leafmap will cluster nearby project markers. The total number of projects within a cluster will be shown at the center of the cluster symbol. When you hover over a cluster, a bounding box for the cluster's region will appear. Clicking on a cluster will zoom the map to the extent of the cluster's bounding box.</p> In\u00a0[\u00a0]: Copied! <pre># Now create a map\nMap = leafmap.Map()\nMap.add_xy_data(df, x=\"x\", y=\"y\", layer_name=\"My D2S Projects\")\nMap\n</pre> # Now create a map Map = leafmap.Map() Map.add_xy_data(df, x=\"x\", y=\"y\", layer_name=\"My D2S Projects\") Map In\u00a0[\u00a0]: Copied! <pre># Create map displaying project boundary for first project\nMap = leafmap.Map()\nMap.add_geojson(projects[1].get_project_boundary(), layer_name=projects[1].title, fill_colors=['#daaa00'], zoom_to_layer=True)\nMap\n</pre> # Create map displaying project boundary for first project Map = leafmap.Map() Map.add_geojson(projects[1].get_project_boundary(), layer_name=projects[1].title, fill_colors=['#daaa00'], zoom_to_layer=True) Map <p>We can also retrieve any map layers associated with our project using the project's <code>get_map_layers</code> method. This method will return a list of GeoJSON FeatureCollections objects for each map layer.</p> In\u00a0[\u00a0]: Copied! <pre># Create map for displaying map layers\nMap = leafmap.Map()\n# Use filter_by_title to find project with map layers\ndemo_projects = projects.filter_by_title(\"Demo\")\nif len(demo_projects) &gt; 0:\n    project_with_map_layers = demo_projects[0]\n    # Returns list of dictionaries in GeoJSON FeatureCollection structure for each project map layer\n    map_layers = project_with_map_layers.get_map_layers()\n    # Display map layers on map\n    for map_layer in map_layers:\n        Map.add_geojson(map_layer, fill_colors=[\"#daaa00\"])\nMap\n</pre> # Create map for displaying map layers Map = leafmap.Map() # Use filter_by_title to find project with map layers demo_projects = projects.filter_by_title(\"Demo\") if len(demo_projects) &gt; 0:     project_with_map_layers = demo_projects[0]     # Returns list of dictionaries in GeoJSON FeatureCollection structure for each project map layer     map_layers = project_with_map_layers.get_map_layers()     # Display map layers on map     for map_layer in map_layers:         Map.add_geojson(map_layer, fill_colors=[\"#daaa00\"]) Map <p>Once finished viewing your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre># Removes access token from future requests\nworkspace.logout()\n</pre> # Removes access token from future requests workspace.logout()"},{"location":"guides/notebooks/05_visualizing_projects_with_leafmap/#visualizing-project-locations-with-leafmap","title":"Visualizing project locations with leafmap\u00b6","text":"<p>This guide will walk you through the steps for visualizing the location of your D2S projects with leafmap.</p> <p>To get started, you will need to have access to a D2S instance where you have created projects and the open-source library leafmap added to your Python environment.</p>"},{"location":"guides/notebooks/06_clipping_rasters_with_d2spy/","title":"Clipping rasters with d2spy","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install d2spy[geo]\n# !pip install leafmap\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install d2spy[geo] # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nfrom datetime import date\n\nimport leafmap\nfrom d2spy.workspace import Workspace\n</pre> import os from datetime import date  import leafmap from d2spy.workspace import Workspace <p>You must connect to your D2S workspace before you can request any data. The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go.</p> <p>Note: This tutorial uses a D2S instance hosted at https://ps2.d2s.org. You will need to have an account and access to data on this instance to use it. Change the URL if you are self-hosting an instance or using an instance hosted elsewhere.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to D2S workspace\nworkspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\")\n</pre> # Connect to D2S workspace workspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\") <p>First we will need to find the project that contains the Cloud Optimized GeoTIFF (COG) we will be clipping.</p> In\u00a0[\u00a0]: Copied! <pre># Change the search term in `.filter_by_title` to match your project\nproject = workspace.get_projects().filter_by_title(\"clip demo\")[0]\nprint(project)\n</pre> # Change the search term in `.filter_by_title` to match your project project = workspace.get_projects().filter_by_title(\"clip demo\")[0] print(project) <p>Next, find the flight that the COG was uploaded to within the project. If you have multiple flights with the same acquisition date you may need to change the index at the end of the first line of code.</p> In\u00a0[\u00a0]: Copied! <pre># Change the date range in `filter_by_date` to match the acquistion date of the flight in your project\nflight = project.get_flights().filter_by_date(date(2022, 6, 23), date(2022, 6, 23))[0]\nprint(flight)\n</pre> # Change the date range in `filter_by_date` to match the acquistion date of the flight in your project flight = project.get_flights().filter_by_date(date(2022, 6, 23), date(2022, 6, 23))[0] print(flight) <p>Now that we have the correct flight selected, we can find the data product. If you have multiple data products with the same data type within this flight you may need to change the index at the end of the first line of code.</p> In\u00a0[\u00a0]: Copied! <pre># Change the search term in `.filter_by_data_type` to match your COG's data type\ndata_product = flight.get_data_products().filter_by_data_type(\"dsm\")[0]\nprint(data_product)\n</pre> # Change the search term in `.filter_by_data_type` to match your COG's data type data_product = flight.get_data_products().filter_by_data_type(\"dsm\")[0] print(data_product) <p>The polygon feature we will be using to clip the COG needs to be in a Python dictionary that matches the GeoJSON polygon feature format. In this example, we will fetch the polygon feature from a map layer previously uploaded to this project.</p> In\u00a0[\u00a0]: Copied! <pre># This project only has one map layer so we can safely access it from the first index position\nmap_layer = project.get_map_layers()[0]\n# The polygon feature is currently inside a GeoJSON Feature Collection\n# Extract the GeoJSON Polygon Feature from the Feature Collection\nclip_feature = map_layer[\"features\"][0]\nprint(clip_feature)\n</pre> # This project only has one map layer so we can safely access it from the first index position map_layer = project.get_map_layers()[0] # The polygon feature is currently inside a GeoJSON Feature Collection # Extract the GeoJSON Polygon Feature from the Feature Collection clip_feature = map_layer[\"features\"][0] print(clip_feature) <p>If the COG is protected we will need to set our D2S API key in the environment. If it is public, this step can be skipped.</p> <p>You can create an API key from the Profile page of your D2S instance (e.g., https://ps2.d2s.org/auth/profile). Be careful with this API key as it can be used to access any of your data products. You can revoke your current API key at any time from the Profile page.</p> In\u00a0[\u00a0]: Copied! <pre>if workspace.api_key:\n    os.environ[\"D2S_API_KEY\"] = workspace.api_key\nelse:\n    # Note, you will need to log in again to fetch the key from workspace.api_key or you can manually enter the key above\n    print(\"Please create an API key from your D2S Profile page\")\n</pre> if workspace.api_key:     os.environ[\"D2S_API_KEY\"] = workspace.api_key else:     # Note, you will need to log in again to fetch the key from workspace.api_key or you can manually enter the key above     print(\"Please create an API key from your D2S Profile page\") <p>We can use leafmap to quickly visualize our COG and clip boundary.</p> In\u00a0[\u00a0]: Copied! <pre>os.environ[\"TITILER_ENDPOINT\"] = \"https://titiler.d2s.org\"\n\nm = leafmap.Map()\nm.add_cog_layer(data_product.url, colormap_name=\"rainbow\", name=\"DSM\")\nm.add_geojson(map_layer, style={\"color\": \"black\", \"weight\": 3, \"fill\": False})\nm\n</pre> os.environ[\"TITILER_ENDPOINT\"] = \"https://titiler.d2s.org\"  m = leafmap.Map() m.add_cog_layer(data_product.url, colormap_name=\"rainbow\", name=\"DSM\") m.add_geojson(map_layer, style={\"color\": \"black\", \"weight\": 3, \"fill\": False}) m In\u00a0[\u00a0]: Copied! <pre>out_filename = \"./tmp/clipped_cog.tif\"\ndata_product.clip(geojson_feature=clip_feature, out_raster=out_filename)\n</pre> out_filename = \"./tmp/clipped_cog.tif\" data_product.clip(geojson_feature=clip_feature, out_raster=out_filename) <p>We will use leafmap once again to visualize the results.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(out_raster, colormap=\"rainbow\")\nm.add_geojson(map_layer, style={\"color\": \"black\", \"weight\": 3, \"fill\": False})\nm\n</pre> m = leafmap.Map() m.add_raster(out_raster, colormap=\"rainbow\") m.add_geojson(map_layer, style={\"color\": \"black\", \"weight\": 3, \"fill\": False}) m <p>Once finished viewing your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre>workspace.logout()\n</pre> workspace.logout()"},{"location":"guides/notebooks/06_clipping_rasters_with_d2spy/#clipping-rasters-with-d2spy","title":"Clipping rasters with d2spy\u00b6","text":"<p>This guide will walk you through the steps for clipping a Cloud Optimized GeoTIFF hosted on D2S with d2spy. We will visualize the results with leafmap.</p> <p>To get started, you will need to have access to a D2S instance where you have created projects and the open-source library leafmap added to your Python environment.</p>"},{"location":"guides/notebooks/06_clipping_rasters_with_d2spy/#save-clipped-raster-locally","title":"Save Clipped Raster Locally\u00b6","text":"<p>The last step will be running the DataProduct's <code>clip</code> method. You will need to provide the fullpath and filename for your output raster.</p>"},{"location":"guides/notebooks/07_3dep_search_by_d2s_projects/","title":"3DEP search by D2S projects","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install pystac_client\n# !pip install numpy\n# !pip install d2spy\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install pystac_client # !pip install numpy # !pip install d2spy In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nfrom pystac_client import Client\n\nfrom d2spy.workspace import Workspace\n</pre> import numpy as np from pystac_client import Client  from d2spy.workspace import Workspace <p>You must connect to your D2S workspace before you can request any data. The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go.</p> <p>Note: This tutorial uses a D2S instance hosted at https://ps2.d2s.org. You will need to have an account and access to data on this instance to use it. Change the URL if you are self-hosting an instance or using an instance hosted elsewhere.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to D2S workspace\nworkspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\")\n</pre> # Connect to D2S workspace workspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\") <p>Locate the project you're interested in for 3DEP data.</p> In\u00a0[\u00a0]: Copied! <pre># Change the search term in `.filter_by_title` to match your project\nproject = workspace.get_projects().filter_by_title(\"INDOT\")[0]\nproject_boundary = project.get_project_boundary()\n</pre> # Change the search term in `.filter_by_title` to match your project project = workspace.get_projects().filter_by_title(\"INDOT\")[0] project_boundary = project.get_project_boundary() <p>In an upcoming step, you will perform a spatial query using STAC API to find 3DEP items located within your project. This query will require providing STAC API with a bounding box, <code>[xmin, ymin, xmax, ymax]</code> for the project.</p> In\u00a0[\u00a0]: Copied! <pre># Load project boundary coordinates as numpy array\nboundary_arr = np.array(project_boundary[\"geometry\"][\"coordinates\"][0])\n# Create a bounding box for the project\nbounding_box = [\n    boundary_arr[:, 0].min(),\n    boundary_arr[:, 1].min(),\n    boundary_arr[:, 0].max(),\n    boundary_arr[:, 1].max()\n]\n</pre> # Load project boundary coordinates as numpy array boundary_arr = np.array(project_boundary[\"geometry\"][\"coordinates\"][0]) # Create a bounding box for the project bounding_box = [     boundary_arr[:, 0].min(),     boundary_arr[:, 1].min(),     boundary_arr[:, 0].max(),     boundary_arr[:, 1].max() ] <p>D2S provides a STAC API that hosts a 3DEP collection for you to search. The API is accessible at https://stac-api.d2s.org. For a more user-friendly interface to browse the data exposed by the API, visit https://stac.d2s.org. In the following cells, you'll connect to the STAC API using pystac_client and search the 3DEP collection using your bounding box.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to STAC API\nclient = Client.open(\"https://stac-api.d2s.org\")\n</pre> # Connect to STAC API client = Client.open(\"https://stac-api.d2s.org\") In\u00a0[\u00a0]: Copied! <pre># Search 3DEP collection\nsearch = client.search(\n    max_items=10,\n    collections=[\"3dep\"],\n    bbox=bounding_box,\n)\n</pre> # Search 3DEP collection search = client.search(     max_items=10,     collections=[\"3dep\"],     bbox=bounding_box, ) In\u00a0[\u00a0]: Copied! <pre># Print STAC Item ID and STAC Browser URL for search results\nstac_browser_base_item_url = \"https://stac.d2s.org/collections/3dep/items\"\nfor item in search.items():\n    print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")\n    # You can also directly access the asset URL from the item\n    # item.assets[\"ept.json\"].href\n</pre> # Print STAC Item ID and STAC Browser URL for search results stac_browser_base_item_url = \"https://stac.d2s.org/collections/3dep/items\" for item in search.items():     print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")     # You can also directly access the asset URL from the item     # item.assets[\"ept.json\"].href <p>Once finished viewing your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre>workspace.logout()\n</pre> workspace.logout()"},{"location":"guides/notebooks/07_3dep_search_by_d2s_projects/#3dep-search-by-d2s-projects","title":"3DEP search by D2S projects\u00b6","text":"<p>This guide will walk you through the steps to search a STAC Catalog using the STAC API to find 3DEP items within a D2S project.</p> <p>To get started, you'll need access to a D2S instance with existing projects. In addition to <code>d2spy</code>, this guide will use Python packages <code>pystac_client</code> and <code>numpy</code>.</p>"},{"location":"guides/notebooks/08_3dep_search_by_polygon_and_clip_with_pdal/","title":"3DEP search by polygon and clip with PDAL","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install geopandas\n# !pip install leafmap\n# !pip install pdal\n# !pip install pystac_client\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install geopandas # !pip install leafmap # !pip install pdal # !pip install pystac_client In\u00a0[\u00a0]: Copied! <pre>import json\nimport sys\n\nimport geopandas as gpd\nimport leafmap\nimport pdal\nfrom pystac_client import Client\n</pre> import json import sys  import geopandas as gpd import leafmap import pdal from pystac_client import Client <p>You will need local polygon data in either shapefile or GeoPackage format for the next cell. GeoPandas will read the local file into a DataFrame. Alternatively, you can comment out the first line, uncomment the second line, and provide the URL to a remote polygon dataset, such as a zipped shapefile.</p> In\u00a0[\u00a0]: Copied! <pre>vector_file = \"/Volumes/jj/data/purdue/d2s_workshop_example_data/boundary.shp\"\n# vector_file = \"https://workshop.d2s.org/sample_data/project_boundary.zip\"\npoly = gpd.read_file(vector_file)\n\n# Now convert the boundary to EPSG:4326\npoly = poly.to_crs(\"EPSG:4326\")\n</pre> vector_file = \"/Volumes/jj/data/purdue/d2s_workshop_example_data/boundary.shp\" # vector_file = \"https://workshop.d2s.org/sample_data/project_boundary.zip\" poly = gpd.read_file(vector_file)  # Now convert the boundary to EPSG:4326 poly = poly.to_crs(\"EPSG:4326\") <p>D2S provides a STAC API that hosts a 3DEP collection for you to search. The API is accessible at https://stac-api.d2s.org. For a more user-friendly interface to browse the data exposed by the API, visit https://stac.d2s.org. In the following cells, you'll connect to the STAC API using pystac_client and search the 3DEP collection using your bounding box.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to STAC API\nclient = Client.open(\"https://stac-api.d2s.org\")\n</pre> # Connect to STAC API client = Client.open(\"https://stac-api.d2s.org\") In\u00a0[\u00a0]: Copied! <pre># Get bounding box [xmin, ymin, xmax, ymax] for polygon\nbounding_box = poly.total_bounds.tolist()\n\n# Search 3DEP collection\nsearch = client.search(\n    max_items=10,\n    collections=[\"3dep\"],\n    bbox=bounding_box,\n)\n</pre> # Get bounding box [xmin, ymin, xmax, ymax] for polygon bounding_box = poly.total_bounds.tolist()  # Search 3DEP collection search = client.search(     max_items=10,     collections=[\"3dep\"],     bbox=bounding_box, ) In\u00a0[\u00a0]: Copied! <pre># Print STAC Item ID and STAC Browser URL for search results\nstac_browser_base_item_url = \"https://stac.d2s.org/collections/3dep/items\"\nitems = []\nfor item in search.items():\n    print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")\n    # You can also directly access the asset URL from the item\n    print(f\"URL: {item.assets['ept.json'].href}\\n\")\n    items.append(item)\n</pre> # Print STAC Item ID and STAC Browser URL for search results stac_browser_base_item_url = \"https://stac.d2s.org/collections/3dep/items\" items = [] for item in search.items():     print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")     # You can also directly access the asset URL from the item     print(f\"URL: {item.assets['ept.json'].href}\\n\")     items.append(item) In\u00a0[\u00a0]: Copied! <pre># Choose the item to clip\nitem = items[1]\n\n# EPT data for USGS 3DEP LiDAR is in EPSG:3857 \n# Read more: (https://github.com/hobuinc/usgs-lidar?tab=readme-ov-file#coordinate-system)\nepsg_code = \"EPSG:3857\"\n\n# Reproject polygon to match first item's coordinate system\npoly = poly.to_crs(epsg_code)\nbounding_box = poly.total_bounds.tolist()\n\n# Get Asset URL for first item\nasset_url = item.assets[\"ept.json\"].href\n</pre> # Choose the item to clip item = items[1]  # EPT data for USGS 3DEP LiDAR is in EPSG:3857  # Read more: (https://github.com/hobuinc/usgs-lidar?tab=readme-ov-file#coordinate-system) epsg_code = \"EPSG:3857\"  # Reproject polygon to match first item's coordinate system poly = poly.to_crs(epsg_code) bounding_box = poly.total_bounds.tolist()  # Get Asset URL for first item asset_url = item.assets[\"ept.json\"].href In\u00a0[\u00a0]: Copied! <pre># Provide different filepath and name if desired\nout_laz_filename = \"./clip.laz\"\nout_tif_filename = \"./clip.tif\"\n\n# Coordinate system for output\nout_epsg = \"EPSG:26916\"\n\n# Pipeline\njson_dict = {\n    \"pipeline\": [\n        {\n            \"bounds\": f\"([{bounding_box[0]}, {bounding_box[2]}], [{bounding_box[1]}, {bounding_box[3]}])\",\n            \"filename\": asset_url,\n            \"type\": \"readers.ept\",\n            \"tag\": \"readdata\"\n        },\n        {\n            \"limits\": \"Classification![7:7]\",\n            \"type\": \"filters.range\",\n            \"tag\": \"nonoise\"\n        },\n        {\n            \"assignment\": \"Classification[:]=0\",\n            \"type\": \"filters.assign\",\n            \"tag\": \"wipeclasses\"\n        },\n        {\n            \"out_srs\": out_epsg,\n            \"type\": \"filters.reprojection\",\n            \"tag\": \"reprojectUTM\"\n        },\n        {\n            \"tag\": \"groundify\",\n            \"type\": \"filters.smrf\"\n        },\n        {\n            \"limits\": \"Classification[2:2]\",\n            \"type\": \"filters.range\",\n            \"tag\": \"classify\"\n        },\n        {\n            \"filename\": out_laz_filename,\n            \"inputs\": [ \"classify\" ],\n            \"type\": \"writers.las\",\n            \"tag\": \"writerslas\"\n        },\n        {\n            \"filename\": out_tif_filename,\n            \"gdalopts\": \"tiled=yes,     compress=deflate\",\n            \"inputs\": [ \"writerslas\" ],\n            \"nodata\": -9999,\n            \"output_type\": \"idw\",\n            \"resolution\": 1,\n            \"type\": \"writers.gdal\",\n            \"window_size\": 6\n        }\n    ]\n}\n</pre> # Provide different filepath and name if desired out_laz_filename = \"./clip.laz\" out_tif_filename = \"./clip.tif\"  # Coordinate system for output out_epsg = \"EPSG:26916\"  # Pipeline json_dict = {     \"pipeline\": [         {             \"bounds\": f\"([{bounding_box[0]}, {bounding_box[2]}], [{bounding_box[1]}, {bounding_box[3]}])\",             \"filename\": asset_url,             \"type\": \"readers.ept\",             \"tag\": \"readdata\"         },         {             \"limits\": \"Classification![7:7]\",             \"type\": \"filters.range\",             \"tag\": \"nonoise\"         },         {             \"assignment\": \"Classification[:]=0\",             \"type\": \"filters.assign\",             \"tag\": \"wipeclasses\"         },         {             \"out_srs\": out_epsg,             \"type\": \"filters.reprojection\",             \"tag\": \"reprojectUTM\"         },         {             \"tag\": \"groundify\",             \"type\": \"filters.smrf\"         },         {             \"limits\": \"Classification[2:2]\",             \"type\": \"filters.range\",             \"tag\": \"classify\"         },         {             \"filename\": out_laz_filename,             \"inputs\": [ \"classify\" ],             \"type\": \"writers.las\",             \"tag\": \"writerslas\"         },         {             \"filename\": out_tif_filename,             \"gdalopts\": \"tiled=yes,     compress=deflate\",             \"inputs\": [ \"writerslas\" ],             \"nodata\": -9999,             \"output_type\": \"idw\",             \"resolution\": 1,             \"type\": \"writers.gdal\",             \"window_size\": 6         }     ] } In\u00a0[\u00a0]: Copied! <pre># Execute pipeline\npipeline = pdal.Pipeline(json.dumps(json_dict))\ncount = pipeline.execute()\n</pre> # Execute pipeline pipeline = pdal.Pipeline(json.dumps(json_dict)) count = pipeline.execute() In\u00a0[\u00a0]: Copied! <pre># Display DTM on map\nm = leafmap.Map()\nm.add_raster(\"clip.tif\", colormap=\"gray\")\nm.add_geojson(json.loads(poly.to_json(to_wgs84=True)), style={\"color\": \"yellow\", \"weight\": 3, \"fill\": False})\nm\n</pre> # Display DTM on map m = leafmap.Map() m.add_raster(\"clip.tif\", colormap=\"gray\") m.add_geojson(json.loads(poly.to_json(to_wgs84=True)), style={\"color\": \"yellow\", \"weight\": 3, \"fill\": False}) m"},{"location":"guides/notebooks/08_3dep_search_by_polygon_and_clip_with_pdal/#3dep-search-by-polygon-and-clip-with-pdal","title":"3DEP search by polygon and clip with PDAL\u00b6","text":"<p>This guide will walk you through the steps to search a STAC Catalog using the STAC API to find 3DEP items within a polygon.</p> <p>This guide will use Python packages <code>geopandas</code>, <code>leafmap</code>, <code>pdal</code>, and <code>pystac_client</code>.</p> <p>Important You'll also need GDAL and PDAL installed on your system. If you're using Conda to manage your Python environment, these libraries will be installed automatically. Otherwise, you'll need to install GDAL and PDAL manually before using pip to install the Python extensions.</p>"},{"location":"guides/notebooks/08_3dep_search_by_polygon_and_clip_with_pdal/#clip-and-export-dtm-with-pdal","title":"Clip and export DTM with PDAL\u00b6","text":"<p>In this final section, you will create and run a PDAL pipeline to clip an EPT dataset from the search results to fit within your polygon boundary. The pipeline will export the clipped point cloud as a .laz file and also generate a DTM for the specified area. For a more in-depth explanation of the pipeline process, refer to the official PDAL documentation: https://pdal.io/en/2.4.3/tutorial/iowa-entwine.html.</p>"},{"location":"guides/notebooks/09_naip_search_by_d2s_projects_and_clip/","title":"NAIP search by D2S projects and clip","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment and run the following line if working out of Google Colab\n# !pip install numpy\n# !pip install pystac_client\n# !pip install d2spy\n</pre> # Uncomment and run the following line if working out of Google Colab # !pip install numpy # !pip install pystac_client # !pip install d2spy In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport numpy as np\nfrom pystac_client import Client\n\nfrom d2spy.extras.utils import clip_by_mask\nfrom d2spy.workspace import Workspace\n</pre> import leafmap import numpy as np from pystac_client import Client  from d2spy.extras.utils import clip_by_mask from d2spy.workspace import Workspace <p>You must connect to your D2S workspace before you can request any data. The <code>Workspace</code> module's <code>connect</code> method can be used to login to a D2S instance and connect to your workspace in one go.</p> <p>Note: This tutorial uses a D2S instance hosted at https://ps2.d2s.org. You will need to have an account and access to data on this instance to use it. Change the URL if you are self-hosting an instance or using an instance hosted elsewhere.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to D2S workspace\nworkspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\")\n</pre> # Connect to D2S workspace workspace = Workspace.connect(\"https://ps2.d2s.org\", \"yourD2Semail@example.com\") <p>Locate the project you're interested in for NAIP data.</p> In\u00a0[\u00a0]: Copied! <pre># Change the search term in `.filter_by_title` to match your project\nproject = workspace.get_projects().filter_by_title(\"INDOT\")[0]\nproject_boundary = project.get_project_boundary()\n</pre> # Change the search term in `.filter_by_title` to match your project project = workspace.get_projects().filter_by_title(\"INDOT\")[0] project_boundary = project.get_project_boundary() <p>In an upcoming step, you will perform a spatial query using STAC API to find NAIP items located within your project. This query will require providing STAC API with a bounding box, <code>[xmin, ymin, xmax, ymax]</code> for the project.</p> In\u00a0[\u00a0]: Copied! <pre># Load project boundary coordinates as numpy array\nboundary_arr = np.array(project_boundary[\"geometry\"][\"coordinates\"][0])\n# Create a bounding box for the project\nbounding_box = [\n    boundary_arr[:, 0].min(),\n    boundary_arr[:, 1].min(),\n    boundary_arr[:, 0].max(),\n    boundary_arr[:, 1].max()\n]\n</pre> # Load project boundary coordinates as numpy array boundary_arr = np.array(project_boundary[\"geometry\"][\"coordinates\"][0]) # Create a bounding box for the project bounding_box = [     boundary_arr[:, 0].min(),     boundary_arr[:, 1].min(),     boundary_arr[:, 0].max(),     boundary_arr[:, 1].max() ] <p>D2S provides a STAC API that hosts a NAIP collection for you to search. The API is accessible at https://stac-api.d2s.org. For a more user-friendly interface to browse the data exposed by the API, visit https://stac.d2s.org. In the following cells, you'll connect to the STAC API using pystac_client and search the NAIP collection using your bounding box.</p> In\u00a0[\u00a0]: Copied! <pre># Connect to STAC API\nclient = Client.open(\"https://stac-api.d2s.org\")\n</pre> # Connect to STAC API client = Client.open(\"https://stac-api.d2s.org\") In\u00a0[\u00a0]: Copied! <pre># Search for items from 2020 in the NAIP collection\nsearch = client.search(\n    max_items=10,\n    collections=[\"naip\"],\n    bbox=bounding_box,\n    datetime=['2020-01-01', '2020-12-31'],\n)\n</pre> # Search for items from 2020 in the NAIP collection search = client.search(     max_items=10,     collections=[\"naip\"],     bbox=bounding_box,     datetime=['2020-01-01', '2020-12-31'], ) In\u00a0[\u00a0]: Copied! <pre># Print STAC Item ID and STAC Browser URL for search results\nstac_browser_base_item_url = \"https://stac.d2s.org/collections/naip/items\"\nitems = []\nfor item in search.items():\n    print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")\n    items.append(item)\n\n# A single item is returned by this example query\nitem = items[0]\n</pre> # Print STAC Item ID and STAC Browser URL for search results stac_browser_base_item_url = \"https://stac.d2s.org/collections/naip/items\" items = [] for item in search.items():     print(f\"ID: {item.id}, URL: {stac_browser_base_item_url}/{item.id}\")     items.append(item)  # A single item is returned by this example query item = items[0] In\u00a0[\u00a0]: Copied! <pre># Print name of assets available in the STAC Item\nfor asset in item.assets:\n    print(asset)\n</pre> # Print name of assets available in the STAC Item for asset in item.assets:     print(asset) In\u00a0[\u00a0]: Copied! <pre># The URL for the NAIP raster is in the \"image\" asset\nnaip_url = item.assets[\"image\"].href\nprint(naip_url)\n</pre> # The URL for the NAIP raster is in the \"image\" asset naip_url = item.assets[\"image\"].href print(naip_url) <p>The NAIP raster is a Cloud Optimized GeoTIFF, allowing us to stream the dataset directly, rather than downloading it in full before clipping it.</p> In\u00a0[\u00a0]: Copied! <pre># Desired location and name for clipped raster\nout_filename = \"/tmp/clipped_naip.tif\"\n\n# Clip the raster\nclip_by_mask(in_raster=naip_url, geojson=project_boundary, out_raster=out_filename)\n</pre> # Desired location and name for clipped raster out_filename = \"/tmp/clipped_naip.tif\"  # Clip the raster clip_by_mask(in_raster=naip_url, geojson=project_boundary, out_raster=out_filename) <p>The results can be visualized with leafmap.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(out_filename)\nm.add_geojson(project_boundary, style={\"color\": \"black\", \"weight\": 3, \"fill\": False})\nm\n</pre> m = leafmap.Map() m.add_raster(out_filename) m.add_geojson(project_boundary, style={\"color\": \"black\", \"weight\": 3, \"fill\": False}) m <p>Once finished viewing your data, you can revoke your authorization session by logging out.</p> In\u00a0[\u00a0]: Copied! <pre>workspace.logout()\n</pre> workspace.logout()"},{"location":"guides/notebooks/09_naip_search_by_d2s_projects_and_clip/#naip-search-by-d2s-projects-and-clip","title":"NAIP search by D2S projects and clip\u00b6","text":"<p>This guide will walk you through the steps to search a STAC Catalog using the STAC API to find NAIP items within a D2S project and clip an item by your D2S project boundary.</p> <p>To get started, you'll need access to a D2S instance with existing projects. In addition to <code>d2spy</code>, this guide will use Python packages <code>leafmap</code>, <code>numpy</code>, and <code>pystac_client</code>.</p>"},{"location":"guides/notebooks/09_naip_search_by_d2s_projects_and_clip/#clip-naip-raster-and-save-locally","title":"Clip NAIP Raster and Save Locally\u00b6","text":"<p>First you need to find the asset within the STAC Item that represents the NAIP image/raster.</p>"}]}